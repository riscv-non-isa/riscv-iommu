[[hw_guidelines]]

== Hardware guidelines
This section provides guidelines to the system/hardware integrator of the
IOMMU in the platform.

=== Integrating an IOMMU as a PCIe device
The IOMMU may be constructed as a PCIe device itself and be discoverable
as a dedicated PCIe function with PCIe defined Base Class 08h, Sub-Class 06h,
and Programming Interface 00h cite:[PCI-CLS].

Such IOMMU must map the IOMMU registers defined in this specification as PCIe
BAR mapped registers.

The IOMMU may support MSI or MSI-X or both. When MSI-X is supported,  the MSI-X
capability block must point to the `msi_cfg_tbl` in BAR mapped registers such that
system software can configure MSI address and data pairs for each message
supported by the IOMMU. The MSI-X PBA may be located in the same BAR or
another BAR of the IOMMU. The IOMMU is recommended to support MSI-X capability.

=== Faults from PMA and PMP
The IO bridge may invoke a PMA and/or a PMP checker on memory accesses from
IO devices or those generated by the IOMMU implicitly to access the in-memory
data structures. When a memory access violates a PMA check or violates a PMP
check, the IO bridge may abort the memory access as specified in
<<IOBR_FAULT_RESP>>.

[[IOBR_FAULT_RESP]]
=== Aborting transactions
If the aborted transaction is an IOMMU-initiated implicit memory access then the
IO bridge signals such access faults to the IOMMU itself. The details of such
signaling is implementation defined.

If the aborted transaction is a write then the IO bridge may discard the write;
the details of how the write is discarded are implementation defined. If the IO
protocol requires a response for write transactions (e.g., AXI) then a response
as defined by the IO protocol may be generated by the IO bridge (e.g., SLVERR on
BRESP - Write Response channel). For PCIe, for example, write transactions are
posted and no response is returned when a write transaction is discarded.

If the faulting transaction is a read then the device expects a completion. The
IO bridge may provide a completion to the device. The data, if returned, in such
completion is implementation defined; usually it is a fixed value such as all 0
or all 1. A status code may be returned to the device in the completion to
indicate this condition. For AXI, for example, the completion status is provided
by SLVERR on RRESP (Read Data channel). For PCIe, for example, the completion
status field may be set to "Unsupported Request" (UR) or "Completer Abort" (CA).

[[RAS]]
=== Reliability, Availability, and Serviceability (RAS)
The IOMMU may support a RAS architecture that specifies the methods for
enabling error detection, logging the detected errors (including their severity,
nature, and location), and configuring means to report the error to an error
handler.

<<<

Some errors, such as those in the IOATC, may be correctable by reloading the
cached in-memory data structures when the error is detected. Such errors are not
expected to affect the functioning of the IOMMU.

Some errors may corrupt critical internal state of the IOMMU and such errors may
lead the IOMMU to a failed state. Examples of such state may include registers
such as the `ddtp`, `cqb`, etc. On entering such a failed state, the IOMMU may
request the IO bridge to abort all incoming transactions.

Some errors, such as corruptions that occur within the internal data paths of
the IOMMU, may not be correctable but the effects of such errors may be contained
to the transaction being processed by the IOMMU.

As part of processing a transaction, the IOMMU may need to read data from
in-memory data structures such as the DDT, PDT, or first/second-stage page tables.
The provider (a memory controller or a cache) of the data may detect that the
data requested has an uncorrectable error and signal that the data is corrupted
and defer the error to the IOMMU. Such technique to defer the handling of the
corrupted data to the consumer of the data is also commonly known as data
poisoning. The effects of such errors may be contained to the transaction that
caused the corrupted data to be accessed.

In the cases where the error affects the transaction being processed but
otherwise allows the IOMMU to continue providing service, the IOMMU may abort
(see <<IOBR_FAULT_RESP>>) the transaction and report the the fault by queuing
a fault record in the `FQ`. For PCIe, for example, a "Completer Abort (CA)"
response is appropriate to abort the transaction. The following cause codes are
used to report such faulting transactions:

* DDT data corruption (cause = 268)
* PDT data corruption (cause = 269)
* MSI PT data corruption (cause = 270)
* MSI MRIF data corruption (cause = 271)
* Internal data-path error (cause = 272)
* First/second-stage PT data corruption (cause = 274)

If the IO bridge is not capable of signaling such deferred errors uniquely
from other errors that prevent the IOMMU from accessing in-memory data
structures then the IOMMU may report such errors as access faults instead
of using the differentiated data corruption cause codes.
