[[intro]]

== Introduction
The IOMMU (sometimes referred to as a system MMU) is a system-level 
memory management unit (MMU) that connects direct-memory-access-capable I/O 
devices to system memory.

For each I/O device connected to the system through an IOMMU, software can 
configure at the IOMMU a device context, which associates with the device a 
specific virtual address space and other per-device parameters. By giving 
devices each their own seperate device context at an IOMMU, each device can be 
individually configured for a different software master, usually a guest OS or 
the main (host) OS. On every memory access made from a device, hardware 
indicates to the IOMMU the originating device by some form of unique device 
identifier, which the IOMMU uses to locate the appropriate device context 
within data structures supplied by software. For PCIe, for example, the 
originating device may be identified by the unique 16-bit triple of PCI bus 
number (8-bit), device number (5-bit), and function number (3-bit) 
(collectively known as routing ID (RID) and optionally upto 8-bit segment 
number when the IOMMU supports multiple segments. This specification refers to
such unique device identifier as `device_id` and supports upto 24-bit wide IDs.

Some devices may support shared virtual addressing which is the ability to 
share process address space with devices. Sharing process address spaces with 
devices allows to rely on core kernel memory management for DMA, removing some 
complexity from application and device drivers. After binding to a device, 
applications can instruct it to perform DMA on buffers obtained with malloc. To
support such addressing, software can configure one or more process context 
into the device context. On every memory access made from a device, the hardware
indicates to the the IOMMU a unique process identifier, which the IOMMU uses
in conjunction with the unique device identifier to locate the appropriate
process context configured by software in the device context. For PCIe, for
example, the process context may be identified by the unique 20-bit process
address space ID (PASID). This specification refers to such unique process 
identifiers as `process_id` and supports upto 20-bit wide IDs.

Using the same S/VS-stage and G-stage page table formats in IOMMU for address 
translation and protections as the CPU’s MMU removes some complexity from the
core kernel memory management for DMA. Use of an identical format also allows
the same G and S/VS-stage tables to be used by both MMU and the IOMMU.

DMA address translation in the IOMMU has certain performance implications for 
DMA accesses as DMA access time may be lengthened due to the time required to 
resolve the supervisor physical address using software provided data structures.
Similar overheads in the CPU MMU are mitigated typically through the use of a
translation look-aside buffer (TLB) to cache these address translations such 
that they may be re-used to reduce the translation overhead on subsequent 
accesses. The IOMMU may employ similar address translation caches (IOATC). The
IOMMU provides mechanisms for software to synchronize the IOATC with the 
memory resident data structures used for address translation when they are
modified. Software may configure the device context with a software defined
context ID called Guest-soft-context-ID (`GSCID`) to indicate that a 
collection of devices are assigned to the same VM and thus access a common 
virtual address space. Software may configure the process context with a 
software defined context ID called Process-soft-context-ID (`PSCID`) to 
identify a collection of process ID that share a common virtual address space.
The IOMMU may use the `GSCID` and `PSCID` to tag entries in the IOATC to avoid
duplications and simplify invalidation operations.

Some devices may participate in the translation process and provide a device
side ATC (DevATC) for its own memory accesses. By providing a DevATC, the 
device shares the translation caching responsibility and thereby reduce 
probability of "thrashing" in the IOATC. The DevATC may be sized by the device
to suit its unique performance requirements and may also be used by the device
to optimize latency by prefetching translations. Such mechanisms require 
close cooperation of the device and the IOMMU using a protocol. For PCIe, for
example, the Address Trnaslation Services (ATS) protocol may be used by the
device to request translations to cache in the DevATC and to synchronize it 
with updates made by software address translation data structures. The
device participating in the address translation process also enables the use
of I/O page faults to avoid the core kernel memory manager from having to make
all physical memory that may be accessed by the device resident at all times.
For PCIe, for example, the device may implement the Page Request Interface (PRI)
to dynamically request the memory manager to make a page resident if it 
discovers the page for which it request a translation was not available. An
IOMMU may support the interfaces to software and the protocols with the device
to enable services such as PCIe ATS and PCIe PRI.

In systems built with an Incoming Message-Signaled Interrupt Controller (IMSIC),
the IOMMU may be programmed by the hypervisor to direct message-signaled 
interrupts (MSI) from devices controlled by the guest OS to a guest interrupt 
file in an IMSIC. Because MSIs from devices are simply memory writes, they 
would naturally be subject to the same address translation that an IOMMU 
applies to other memory writes. However, the Advanced Interrupt Architecture 
requires that IOMMUs treat MSIs directed to virtual machines specially, in 
part to simplify software, and in part to allow optional support for 
memory-resident interrupt files. The device context is configured by software
with parameters to identify memory writes as MSI and to be translated using a
MSI address translation table configured by software in the device context.

=== Glossary
.Terms and definitions
[width=75%]
[%header, cols="5,20"]
|===
| Term            | Definition
| ATS             | Address Translation Services - a PCIe protocol to support
                    DevATC.
| DC              | Device Context
| DDT             | Device-directory-table: A radix-tree structure traversed
                    using the unique device identifier to locate the Device
                    Context structure.
| DDI             | Device-directory-index: a sub-field of the unique device 
                    identifier used as a index into a leaf or non-leaf DDT
                    structure.
| Device Context  | A hardware representation of state that identifies a 
                    device and the VM to which the device is assigned.
| Device ID       | A identification number that is up to 24-bits to identify 
                    the source of a DMA or interrupt request. For PCIe devices 
                    this is the routing-ID.
| DevATC          | A address translation cache at the device.
| DMA             | Direct Memory Access
| GPA             | Guest Physical Address: an address in the virtualized 
                    physical memory space of a virtual machine.
| GSCID           | Guest soft-context identifier: An identification number used
                    by software to uniquely identify a collection of devices 
                    assigned to a virtual machine. An IOMMU may tag IOATC 
                    entries with the GSCID. Device contexts programmed with
                    same GSCID must also be programmed with identical G-stage
                    page tables.
| Guest           | Software in a virtual machine.
| Hypervisor      | Software entity that controls virtualization.
| IOATC           | IOMMU Address Translation Cache: cache in IOMMU that caches
                    data structures used for address translations.
| IOVA            | I/O Virtual Address: Virtual address for DMA by devices
| MSI             | Message Signaled Interrupts.
| PASID           | Process Address Space Identifier that identifies the 
                    address space of a process. The PASID value is provided in 
                    the PASID TLP prefix of the request.
| PBMT            | Page-Based Memory Types
| PPN             | Physical Page Number
| PRI             | Page Request Interface - a PCIe protocol that enables 
                    devices to request OS memory manager services to make pages
                    resident.
| PT              | Page Table
| PTE             | Page Table Entry. A leaf or non-leaf entry in a page table.
| PC              | Process Context
| PDI             | Process-directory-index: a sub field of the unique process
                    identifier used to index into a leaf or non-leaf PDT 
                    structure.
| Process ID      | A identification number that is up to 20-bits to identify
                    a process context. For PCIe devices this is the PASID.
| PSCID           | Process soft-context identifier: An identification number
                    used by software to identify a unique address space. The 
                    IOMMU may tag IOATC entries with PSCID.
| PDT             | Process-directory-table: A radix tree data structure 
                    traversed using the unique Process identifier to locate the
                    process context structure.
| Reserved        | A register or data structure field reserved for future use.
                    Reserved fields in data structures must be set to 0 by 
                    software. Software must ignore reserved fields in registers
                    and preserve the value held in these fields when writing 
                    values to other fields in the same register.
| SPA             | Supervisor Physical Address: Physical address used to 
                    to access memory and memory-mapped resources.
| VA              | Virtual Address
| VM              | Virtual Machine: An efficient, isolated duplicate of a real
                    computer system. In this specification it refers to the 
                    collection of resoures and state that is accessible when 
                    a RISC-V hart executes with V=1.
| VMM             | Virtual Machine Monitor. Also referred to as hypervisor.
| VS              | Virtual Supervisor: supervisor privilege in virtualization
                    mode.
| WARL            | Write any values, reads legal values: attribute of a  
                    register field that is only defined for a subset of bit 
                    encodings, but allow any value to be written while 
                    guaranteeing to return a legal value whenever read. 
| WPRI            | Reserved Writes Preserve Values, Reads ignore Values: 
                    attribute of a register field that is reserved for future
                    use. 
|===


=== Usage models


==== Non-virtualized OS

A non-virtualized OS may use the IOMMU for the following significant system-level 
functionalities:

. Protect the operating system from bad memory accesses from errant devices
. Support 32-bit devices in 64-bit environment (avoidance of bounce buffers)
. Support mapping of contiguous virtual addresses to an underlying fragmented physical addresses (avoidance of scatter/gather lists)
. Dynamic redirection of interrupts
. Support shared virtual addressing

In the absence of an IOMMU, a device driver must program devices with Physical 
Addresses, which implies that DMA from a device could be used to access
any memory, such as privileged memory, and cause malicious or unintended
corruptions. This may be caused by hardware bugs, device driver bugs, or 
by malicious software.

The IOMMU offers a mechanism for the OS to defend against such unintended 
corruptions by limiting the memory that can be accessed by devices using DMA. 
Indeed, the Operating System configures the IOMMU to use the S-stage page table 
to translate IOVA to SPA and thereby limit the addresses that may be accessed.

The OS may also use the MSI address translation capability to dynamically 
redirect interrupts from one RISC-V hart to another without needing to reprogram 
the devices themself.

Legacy 32-bit devices cannot access the memory above 4 GiB. The integration of 
the IOMMU, through its address remapping capability, offers a simple mechanism 
for the DMA to directly access any address in the system (with appropriate access
 permission). Without an IOMMU, the OS must resort to copying data through
buffers (also known as bounce buffers) allocated in memory below 4 GiB and
thereby improves system performance.

The IOMMU can be useful as it permits to allocate large regions of memory 
without the need to be contiguous in physical memory. Indeed, a contiguous 
virtual address range can be mapped to a fragmented physical addresses.

The IOMMU can be used to support shared virtual addressing which is the ability 
to share process address space with devices. Sharing process address spaces with 
devices allows to rely on core kernel memory management for DMA, removing some 
complexity from application and device drivers. 

.Device isolation in non-virtualized OS
["ditaa",shadows=false, separation=false, fontsize: 16]
....
+-----------------+ +--------------+ 
| non -privileged | |  privileged  |
|      memory     | |    memory    |
|                 | |              |
|       ^         | |              |
+-------|---------+ +--------------+
        | 
+-------|--------------+
|       |       IOMMU  |
| +-------------+      |
| |   device    |      |
| | S -stage PT |      |                    
| +-------------+      |
|       ^              |
+-------|--------------+
        | 
   +--------+
   | Device |
   +--------+
....

==== Hypervisor

IOMMU makes it possible for a guest operating system, running in a virtual 
machine, to be given direct control of an I/O device with only minimal 
hypervisor intervention. 

A guest OS with direct control of a device will program the device with guest 
physical addresses, because that is all the OS knows. When the device then 
performs memory accesses using those addresses, an IOMMU is responsible for 
translating those guest physical addresses into supervisor physical addresses, 
referencing address-translation data structures supplied by the hypervisor.

To handle MSIs from a device controlled by a guest OS, the hypervisor configures
an IOMMU to redirect those MSIs to a guest interrupt file in an IMSIC or to a 
memory-resident interrupt file. The IOMMU is responsible to use the MSI 
address-translation data structures supplied by the hypervisor to perform the
MSI redirection.

The following diagram illustrates the concept. The device D1 is directly
assigned to VM-1 and device D2 is directly assigned to VM-2. The VMM configures
the G-stage page table to be used by each device and restricts the memory
that can be accessed by D1 to VM-1 associated memory and from D2 to VM-2
associated memory.

.DMA translation to enable direct device assignment
["ditaa",shadows=false, separation=false, fontsize: 16]
....
+----------------+ +----------------+ 
|     VM - 1     | |     VM - 2     |
|     memory     | |     memory     |
|      ^         | |       ^        |
+------|---------+ +-------|--------+
       |                   |
+------|-------------------|--------+
|      |       IOMMU       |        |
| +------------+     +------------+ |
| |  device D1 |     |  device D2 | |
| | G -stage PT|     | G -stage PT| |                    
| +------------+     +------------+ |
|      ^                   ^        |
+------|-------------------|--------+
       |                   |
  +-----------+      +-----------+ 
  | Device D1 |      | Device D2 |
  +-----------+      +-----------+
....

==== Guest OS

The presence of an IOMMU allows each device to be individually configured 
for a different software master, usually a guest OS or the main (host) OS.

On implementations of the IOMMU that support two stages of translation (VS-stage
and G-stage), the G-stage translation (or second stage of translation) is 
intended to virtualize device DMA to the Guest OS physical address space. Devices
can be assigned to Guest OS which can directly program the device to do DMA with 
its Guest Physical Addresses (GPA). The Hypervisor or Host OS will set up and 
configure the IOMMU to perform GPA to PA translation using G-stage page tables. 
The use of the G-stage page tables limits the physical memory accessible by a 
device controlled by the guest OS to the memory allocated to its virtual machine. 

The Hypervisor may then provide a virtual IOMMU facility, through hardware 
emulation or by enlightening the Guest OS to use a software interface with
the Hypervisor (also known as para-virtualization). The Guest OS may then
use the facilities provided by the virtual IOMMU to avail the same benefits
as those discussed for a Non-virtualized OS. The Guest OS employs a page table,
really a VS-stage page table, to perform similar configurations for the device a 
Non-virtulized OS.

With two-stage address translations enabled, the IOVA may be first translated to 
a GPA using the VS-stage page tables managed by the guest OS and the GPA 
translated to a SPA using the G-stage page tables managed by the hypervisor.

The following diagram illustrates the concept. The IOMMU is configured to 
perform two-stage address translation translation (VS-stage and G-stage ) for the
device (D1), is configured to to perform G-stage only translation for another 
device (D2). The host OS or hypervisor may also retain a device, such as D3, for 
its own use and for configure the IOMMU to perform a single-stage (S-stage) 
translation.

.Address translation in IOMMU for Guest OS
["ditaa",shadows=false, separation=false, fontsize: 16]
....
+----------------------------------------------------+ 
|      Main memory                                   |
|                                                    |
|                                                    |
|      ^                  ^                 ^        |
+------|------------------|-----------------|--------+
       |                  |                 |
+------|------------------|-----------------|--------+
|      |       IOMMU      |                 |        |
| +------------+     +------------+         |        |
| |  device D1 |     |  device D2 |         |        |
| | G -stage PT|     | G -stage PT|         |        |                    
| +------------+     +------------+         |        |
|      ^                  ^                 |        |
|      |                  |                 |        |
| +------------+          |         +-------------+  |
| |  device D1 |          |         |  device D3  |  |
| |VS -stage PT|          |         | S -stage PT |  |
| +------------+          |         +-------------+  |
|      ^                  |                 ^        |
+------|------------------|-----------------|--------+
       |                  |                 |
  +-----------+     +-----------+     +-----------+ 
  | Device D1 |     | Device D2 |     | Device D3 |
  +-----------+     +-----------+     +-----------+
....

The hypervisor may use the MSI address translation capability to dynamically 
redirect interrupts from guest controlled devices to the guest assigned 
interrupt register file of an IMSIC in the RISC-V hart.

=== Placement and data flow

The following figure shows an example of a typical SOC with RISC-V hart(s). The
SOC incorporates memory controllers and several IO devices. This SOC also 
incorporates two instances of the IOMMU. The first instance interfaces one IO 
Device A to the system fabric and the second instance interfaces several clients 
(IO Devices B, and C) to the system fabric. As shown in this figure, the IO Bridge
along with the IOMMU is placed between the device(s) and the fabric or 
interconnect. IO Devices can perform DMA transactions using IO Virtual Addresses 
(VA, GVA or GPA) or any other bus addresses in inbound transactions that the 
IOMMU will translate into Physical Addresses (PA).

The device may be directly connected to the IOMMU or may be connected through I/O 
ports using a protocol such as PCI Express (PCIe). The outbound transactions to 
the device do not transit through the IOMMU.

The IO Device A in the example is representing Root Ports connected to several 
endpoints with or without ATC support. The IOMMU may support ATS in order to 
manage the endpoint’s device address translation cache (DevATC).

.Example of IOMMUs integration in SoC.
image::placement.svg[width=800]

The IOMMU handles only inbound address translation and protection. It does not 
manage the data of the inbound transactions. The IOMMU behaves like a look-aside 
IP to the IO bridge and has several interfaces:

* Host interface: it is a slave interface to the IOMMU for the harts to access 
  its internal MMIO registers and perform its global configuration or maintenance.
* Device Translation Request interface: it is a slave interface, which receives 
  the incoming virtual address requests from one or more IO devices. Along with 
  the device address and attributes, a `device_id` (and `process_id`, if any) is 
  provided to the IOMMU in order to uniquely identify the source of the request 
  and potentially its process. Thanks to the unique hardware identifier 
  {`device_id`, `process_id`}, the IOMMU is able to retrieve the context 
  information to perform the requested address translation.
* The Data Structure interface for the IOMMU implicit access to memory: it is a 
  master interface to the system interconnect to fetch the required data 
  structure from main memory. This interface is used to access:
.. the device and process directories to get the context information and translation rules
.. the page tables to get the translated address for S/VS and G-stage
.. the queues for software's interface (command queue, fault queue, and page request queue)
* Device Translation Completion interface: it is a master interface which 
  provides the requested translated Physical Address and an error status. As the 
  IOMMU may not respond to requests in order, this interface will also provide 
  some attributes as received on the Device Translation Request interface and the 
  resolved Paged-Based Memory Type, if Svpbmt is supported (the resolved 
  attribute is based on PBMT from first and/or second stage page tables).
* Optionally an ATS interface in order to communicate with the PCIe Root Port. 
  This interface is used to service an ATS request, to invalidate cached entries 
  in the device's ATC and to request pages through the PCIe Page Request 
  Interface mechanism.

.IOMMU interfaces.
image::interfaces.svg[width=800]

Similar to the RISC-V harts, physical memory attributes (PMA) and physical memory 
protection (PMP) checks must be completed on any inbound IO transactions even when
the IOMMU is in bypass (bare state). The placement and integration of the PMA and 
IOPMP (and other variants) checkers is a platform choice.

PMA and IOPMP checkers reside outside the IOMMU. The example above is showing 
them in the IO bridge.

Implicit accesses by the IOMMU itself through the data structure interface are 
checked by the PMA checker. PMAs are tightly tied to a given physical platform’s
organization, many details are inherently platform-specific.

The IOMMU provides the resolved PBMT (PMA, IO, NC) along with the translated 
address on the device translation completion interface to the I/O bridge. The 
PMA in I/O bridge resolves the final attributes using the overrides requested by 
PBMT and PMA type.

The IOPMP or other variants may use the hardware ID of the bus master to determine
physical memory access privileges. Since the IOMMU itself is a bus master for its 
implicit accesses, the IOMMU hardware ID may be used by the IOPMP to select the 
appropriate access control rules.

=== IOMMU features
The version 1.0 of the RISC-V IOMMU specification supports the following 
features:

* Memory-based device context to locate parameters and address translations
  structures. The device context is located using the hardware provided 
  unique `device_id`. The supported `device_id` width may be up to 24-bit. 
  IOMMU is required to support at least one of the valid `device_id` widths as
  specified in <<DATA_STRUCTURES>>.

* Memory-based process context to locate parameters and address translation
  structures using hardware provide unique `process_id`. The supported 
  `process_id` may be up to 20-bit. IOMMU is required to support at least one
  of the valid `process_id` widths as specified in <<DATA_STRUCTURES>>

* IOMMU must support 16-bit GSCIDs and 20-bit PSCIDs.

* An implementation may support only the VS/S-stage of address translation,
  only G-stage address translation, or two stage address translation. 

* VS/S-stage and/or G-stage virtual-memory system as specified by the RISC-V
  privileged specification to allow software flexibility to use a common page 
  table for CPU MMU as well as IOMMU or to use a separate page table for the
  IOMMU.

* Upto 57-bit virtual-address width and 59-bit guest-physical-address width.

* Support for hardware management of page-table entry Accessed and Dirty bits
  is optional for the IOMMU.

* Support for MSI address translation as specified by RISC-V Advanced Interrupt
  Architecture (AIA) is optional. When MSI address translation is supported 
  using flat MSI page tables then supporting memory-resident-interrupt-files is
  optional.

* Supporting Svnapot extension is optional.

* Supporting Svpbmt extension is optional.

* IOMMU may optionally support the PCIe ATS and PRI services. When ATS is 
  supported the IOMMU may optionally support the ability to translate to a GPA
  instead of a SPA in response to a translation request.

* IOMMU may optionally support an hardware performance monitoring unit (PMU). If 
  a PMU is supported then the IOMMU must support the cycles counter and at least 
  7 hardware performance monitoring counters must be supported.

* The IOMMU may use MSI or wire-based-interrupts to request service from 
  software. At least one method of generating interrupts from the IOMMU must be
  supported.

Software may discover the supported features using the <<CAP, `capabilities`>>
register of the IOMMU.





