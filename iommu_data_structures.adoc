[[DATA_STRUCTURES]]
== Data Structures
A data structure called device-context (`DC`) is used by the IOMMU to associate
a device with an address space and to hold other per-device parameters used
by the IOMMU to perform address translations. A radix-tree data structure called
device directory table (DDT) that is traversed using the `device_id` is used to
locate the `DC`.

The address space used by a device may require single-stage or two-stage address
translation and protection. Two-stage address translation may required when the
control of the device is passed through to a Guest OS. Single-stage address
translation using a S-stage page table may be used when the control of the
device is retained by the hypervisor or Host OS itself.

When two-stage address translation is used the `DC` holds the PPN of the root
G-stage page table; a guest-soft-context-ID (`GSCID`), which facilitates
invalidations of cached address translations on a per-virtual-machine basis; and
the G-stage address translation scheme.

Some devices supports multiple contexts where each context may be associated
with a different process and thus a different virtual address space. The context
in such devices may be configured with a `process_id` that identifies the
address space. When making a memory access, such devices signal the `process_id`
along with the `device_id` to identify the accessed address space. An example of
such a device is a GPU that supports multiple process contexts, where each
context is associated with a different user process, such that the GPU may
access memory using the virtual address provided by the user process itself. To
support selecting an address space associated with the `process_id`, the `DC`
holds the PPN of the root Process Directory Table (PDT), a radix-tree data
structure, indexed using fields of the `process_id` to locate a data structure
called the Process Context (`PC`).

When a PDT is active, the controls for S-stage or VS-stage address translation
are held in the (`PC`).

When a PDT is not active, the controls for S-stage or VS-stage address
translation are be held in the `DC` itself.

The S/VS-stage address translation controls include the PPN of the root
S/VS-stage page table; a process-soft-context-ID (`PSCID`), which facilitates
invalidations of cached address translations on a per-address-space basis; and
the S/VS-stage address translation scheme.

To handle MSIs from a device controlled by a guest OS, an IOMMU must be able to
redirect those MSIs to a guest interrupt file in an IMSIC. Because MSIs from
devices are simply memory writes, they would naturally be subject to the same
address translation that an IOMMU applies to other memory writes. However,
the IOMMU architecture may treat MSIs directed to virtual machines specially, in
part to simplify software, and in part to allow optional support for
memory-resident interrupt files. To support this capability, the architecture
adds to the device contexts an MSI address mask and address pattern, used together
to recognize certain memory writes from the device as being MSIs; and the real
physical address of an MSI page table for controlling the translation and/or
conversion of MSIs from the device.

[NOTE]
====
A device context is given an independent page table for MSIs for two reasons:

First, hypervisors running under Linux or a similar OS can benefit from separate
control of MSI translations to help simplify the case when virtual harts are
migrated from one physical hart to another. When a virtual hart’s interrupt
files are mapped to guest interrupt files in the real machine, migration of the
virtual hart causes the physical guest interrupt files underlying those virtual
interrupt files to change. However, because on other systems (not RISC-V) the
migration of a virtual hart does not affect the mapping from guest physical
addresses to real physical addresses, the internal functions of Linux that
perform this migration are not set up to modify an IOMMU’s address-translation
tables to adjust for the changing physical locations of RISC-V virtual interrupt
files. Giving a hypervisor control of a separate MSI translation table at an
IOMMU bypasses this limitation. The MSI page table can be modified at will by
the hypervisor and/or by the subsystem that manages interrupts without
coordinating with the many other OS components concerned with regular address
translation.

Second, specifying a separate MSI page table facilitates the use of
memory-resident interrupt files (MRIFs), which are introduced in Section
<<MRIF_PTE>>.  A dedicated MSI page table can easily support a special table
entry format for MRIFs (Section <<MRIF_PTE>> that would be entirely foreign and
difficult to retrofit to any other address-translation data structures.
====

The `DC` further holds controls for the type of transactions that a device is
allowed to generate. One example of such a control is whether the device is
allowed to use the PCIe defined Address Translation Service (ATS).

Two formats of the device-context structure are supported:

* *Base Format* - is 32-bytes in size used when the special treatment of MSI
  as specified in <<MSI_TRANS>> is not supported by the IOMMU.

* *Extended Format* - is 64-bytes in size and extends the base format `DC` with
  additional fields to translate MSIs as specified in <<MSI_TRANS>>.

If `capabilities.MSI_FLAT` is 1 then the Extended Format is used else the Base
Format is used.

The DDT used to locate the `DC` may be configured to be a 1, 2, or 3 level
radix-table depending on the maximum width of the `device_id` supported. The
partitioning of the `device_id` to obtain the device directory indexes (DDI) to
traverse the DDT radix-tree table are as follows:

.Base format `device_id` partitioning

[wavedrom, , ]
....
{reg: [
  {bits: 7, name: 'DDI[0]'},
  {bits: 9, name: 'DDI[1]'},
  {bits: 8, name: 'DDI[2]'},
], config:{lanes: 1, hspace:1024, fontsize: 16}}
....

.Extended format `device_id` partitioning

[wavedrom, , ]
....
{reg: [
  {bits: 6, name: 'DDI[0]'},
  {bits: 9, name: 'DDI[1]'},
  {bits: 9, name: 'DDI[2]'},
], config:{lanes: 1, hspace:1024, fontsize: 16}}
....

The PDT may be configured to be a 1, 2, or 3 level radix table depending on the
maximum width of the `process_id` supported for that device.  The partitioning
of the `process_id` to obtain the process directory indices (PDI) to traverse
the PDT radix-tree table are as follows:

.`process_id` partitioning for PDT radix-tree traversal

[wavedrom, , ]
....
{reg: [
  {bits: 8, name: 'PDI[0]'},
  {bits: 9, name: 'PDI[1]'},
  {bits: 3, name: 'PDI[2]'},
], config:{lanes: 1, hspace:1024, fontsize: 16}}
....
[NOTE]
====
The `process_id` partitioning is designed to required a maximum of 4 KiB, a
page, of memory for each process directory table. The root of the table when
using a 20-bit wide `process_id` is not fully populated. The option of making
the root table occupy 32 KiB was considered but not adopted as these tables
are allocated at run time and contiguous memory allocation larger than a page
may stress the Guest and hypervisor memory allocators.
====

[NOTE]
====
All RISC-V IOMMU implementations are required to support DDT and PDT located
in main memory. Supporting data structures in I/O memory is not required but
is not prohibited by this specification.
====

=== Device-Directory-Table (DDT)
DDT is up to 3-level radix tree indexed using the device directory index (DDI)
bits of the `device_id`.

The following diagrams illustrate the DDT radix-tree. The PPN of the root
device-directory-table is held in a memory-mapped register called the
device-directory-table pointer (`ddtp`).

Each valid non-leaf (`NL`) entry is 8-bytes in size and holds the PPN of the
next device-directory-table.

A valid leaf device-directory-table entry holds the device-context (`DC`).

.Three, two and single-level device directory with extended format `DC`
["ditaa",shadows=false, separation=false, font=courier, fontsize: 16]
....
  +-------+-------+-------+      +-------+-------+    +-------+
  |DDI[2] |DDI[1] |DDI[0] |      |DDI[1] |DDI[0] |    |DDI[0] |
  +--+----+--+----+--+----+      +-+-----+-+-----+    +-+-----+
     |       |       |             |       |            |
     +-9−bit +-9−bit +-6−bit       +-9−bit +-6−bit      +-6−bit
     |       |       |             |       |            |
     |  +--+ |  +--+ |  +--+       |  +--+ |  +--+      |   +--+
     |  |  | |  |  | |  |  |       |  |  | |  |  |      |   |  |
     |  |  | |  |  | |  +--+       |  |  | |  +--+      |   |  |
     |  |  | |  |  | +->|DC|       |  |  | +->|DC|      |   |  |
     |  |  | |  +--+    +--+       |  |  |    +--+      |   |  |
     |  |  | +->|NL+-+  |  |       |  +--+    |  |      |   |  |
     |  |  |    +--+ |  |  |       +->|NL+-+  |  |      |   +--+
     +->+--+    |  | |  |  |          +--+ |  |  |      +-->|DC|
        |NL+-+  |  | |  |  |          |  | |  |  |          +--+
        +--+ |  |  | |  |  |          |  | |  |  |          |  |
        |  | |  |  | |  |  |          |  | |  |  |          |  |
ddtp--->+--+ +->+--+ +->+--+  ddtp--->+--+ +->+--+  ddtp--->+--+
....

.Three, two and single-level device directory with base format `DC`
["ditaa",shadows=false, separation=false, font=courier, fontsize: 16]
....
  +-------+-------+-------+      +-------+-------+    +-------+
  |DDI[2] |DDI[1] |DDI[0] |      |DDI[1] |DDI[0] |    |DDI[0] |
  +--+----+--+----+--+----+      +-+-----+-+-----+    +-+-----+
     |       |       |             |       |            |
     +-8−bit +-9−bit +-7−bit       +-9−bit +-7−bit      +-7−bit
     |       |       |             |       |            |
     |  +--+ |  +--+ |  +--+       |  +--+ |  +--+      |   +--+
     |  |  | |  |  | |  |  |       |  |  | |  |  |      |   |  |
     |  |  | |  |  | |  +--+       |  |  | |  +--+      |   |  |
     |  |  | |  |  | +->|DC|       |  |  | +->|DC|      |   |  |
     |  |  | |  +--+    +--+       |  |  |    +--+      |   |  |
     |  |  | +->|NL+-+  |  |       |  +--+    |  |      |   |  |
     |  |  |    +--+ |  |  |       +->|NL+-+  |  |      |   +--+
     +->+--+    |  | |  |  |          +--+ |  |  |      +-->|DC|
        |NL+-+  |  | |  |  |          |  | |  |  |          +--+
        +--+ |  |  | |  |  |          |  | |  |  |          |  |
        |  | |  |  | |  |  |          |  | |  |  |          |  |
ddtp--->+--+ +->+--+ +->+--+  ddtp--->+--+ +->+--+  ddtp--->+--+
....

==== Non-leaf DDT entry

A valid (`V==1`) non-leaf DDT entry provides PPN of the next level DDT.

.Non-leaf device-directory-table entry

[wavedrom, , ]
....
{reg: [
  {bits: 1,  name: 'V',        attr: '1'},
  {bits: 9, name: 'reserved', attr: '9'},
  {bits: 44, name: 'PPN',      attr: '44'},
  {bits: 10,  name: 'reserved', attr: '10'},
], config:{lanes: 2, hspace:1024, fontsize: 16}}
....

==== Leaf DDT entry
The leaf DDT page is indexed by `DDI[0]` and holds the device-context (`DC`).

In base-format the `DC` is 32-bytes. In extended-format the `DC` is 64-bytes.

.Base-format device-context
[wavedrom, , ]
....
{reg: [
  {bits: 64,  name: 'Translation-control (tc)'},
  {bits: 64,  name: 'IO Hypervisor guest address translation and protection (iohgatp)'},
  {bits: 64,  name: 'Translation-attributes (ta)'},
  {bits: 64,  name: 'First-stage-context (fsc)'},
], config:{lanes: 4, hspace: 1024, fontsize: 16}}
....

.Extended-format device-context
[wavedrom, , ]
....
{reg: [
  {bits: 64,  name: 'Translation-control (tc)'},
  {bits: 64,  name: 'IO Hypervisor guest address translation and protection (iohgatp)'},
  {bits: 64,  name: 'Translation-attributes (ta)'},
  {bits: 64,  name: 'First-stage-context (fsc)'},
  {bits: 64,  name: 'MSI-page-table pointer (msiptp)'},
  {bits: 64,  name: 'MSI-address-mask (msi_addr_mask)'},
  {bits: 64,  name: 'MSI-address-pattern (msi_addr_pattern)'},
  {bits: 64,  name: 'reserved'},
], config:{lanes: 8, hspace: 1024, fontsize: 16}}
....

The `DC` is interpreted as four 64-bit doublewords in base-format and as eight
64-bit doublewords in extended-format.  The byte order of each of the
doublewords in memory, little-endian or big-endian, is the endianness as
determined by `fctl.BE` (<<FCTRL>>). The IOMMU may read the `DC` fields in any
order.

==== Device-context fields
===== Translation control (`tc`)

.Translation control (`tc`) field
[wavedrom, , ]
....
{reg: [
  {bits: 1,  name: 'V'},
  {bits: 1,  name: 'EN_ATS'},
  {bits: 1,  name: 'EN_PRI'},
  {bits: 1,  name: 'T2GPA'},
  {bits: 1,  name: 'DTF'},
  {bits: 1,  name: 'PDTV'},
  {bits: 1,  name: 'PRPR'},
  {bits: 1,  name: 'GADE'},
  {bits: 1,  name: 'SADE'},
  {bits: 1,  name: 'DPE'},
  {bits: 1,  name: 'SBE'},
  {bits: 1,  name: `GADFE`},
  {bits: 1,  name: `SADFE`},
  {bits: 19, name: 'reserved'},
  {bits: 32, name: 'Designated for custom use'},
], config:{lanes: 4, hspace: 1024, fontsize: 16, fontsize: 16}}
....

`DC` is valid if the `V` bit is 1; If it is 0, all other bits in `DC` are
don't-care and may be freely used by software.

If the IOMMU supports PCIe ATS specification (see `capabilities` register),
the `EN_ATS` bit is used to enable ATS transaction processing. If `EN_ATS`
is set to 1, IOMMU supports the following inbound transactions; otherwise
they are treated as unsupported requests.

* Translated read for execute transaction
* Translated read transaction
* Translated write/AMO transaction
* PCIe ATS Translation Request
* PCIe ATS Invalidation Completion Message

If the `EN_ATS` bit is 1 and the `T2GPA` bit is set to 1 the IOMMU returns a GPA
, instead of a SPA, as the translation of an IOVA in response to a  PCIe ATS
Translation Request from the device.  In this mode of operations, the ATC in the
device caches a GPA as a translation for an IOVA and uses the GPA as the address
in subsequent translated memory access transactions. Usually translated requests
use a SPA and need no further translation to be performed by the IOMMU. However
when `T2GPA` is 1, translated requests from a device use a GPA and are
translated by the IOMMU using the G-stage page table to a SPA. The `T2GPA`
control enables a hypervisor to contain DMA from a device, even if the device
misuses the ATS capability and attempts to access memory that is not associated
with the VM.

[NOTE]
====
When `T2GPA` is enabled, the addresses provided to the device in response to a
PCIe ATS Translation Request cannot be directly routed by the I/O fabric
(e.g. PCI switches) that connect the device to other peer devices and to host.
Such addresses are also cannot be routed within the device when peer-to-peer
transactions within the device (e.g. between functions of a device) are
supported.

Hypervisors that configure `T2GPA` to 1 must ensure through protocol specific
means that translated accesses are routed through the host such that the IOMMU
may translate the GPA and then route the transaction based on PA to memory or
to a peer device. For PCIe, for example, the Access Control Service (ACS) must
be configured to always redirect peer-to-peer (P2P) requests upstream to the
host.

Use of `T2GPA` set to 1 may not be compatible with devices that implement caches
tagged by the translated address returned in response to a PCIe ATS Translation
Request.

As an alternative to setting `T2GPA` to 1, the hypervisor may establish a trust
relationship with the device if authentication protocols are supported by the
device. For PCIe, for example, the PCIe component measurement and authentication
(CMA) capability provides a mechanism to verify the devices configuration and
firmware/executable (Measurement) and hardware identities (Authentication) to
establish such a trust relationship.
====

If `EN_PRI` bit is 0, then PCIe "Page Request" messages from the device are
invalid requests. A "Page Request" message received from a device is responded to
with a "Page Request Group Response" message. Normally, a software handler
generates this response message. However, under some conditions the IOMMU itself
may generate a response. For IOMMU generated "Page Request Group Response"
messages the PRG-response-PASID-required (`PRPR`) bit when set to 1 indicates
that the IOMMU response message should include a PASID if the associated
"Page Request" had a PASID.

[NOTE]
====
Functions that support PASID and have the "PRG Response PASID Required"
capability bit set to 1, expect that "Page Request Group Response" messages will
contain a PASID if the associated "Page Request" message had a PASID. If the
capability bit is 0, the function does not expect PASID on any "Page Request
Group Response" message and the behavior of the function if it receives the
response with a PASID is undefined. The `PRPR` bit should be configured
with the value held in the "PRG Response PASID Required" capability bit.
====

Setting the disable-translation-fault - `DTF` - bit to 1 disables reporting of
faults encountered in the address translation process. Setting `DTF` to 1 does
not disable error responses from being generated to the device in response to
faulting transactions. Setting `DTF` to 1 does not disable reporting of faults
from the IOMMU that are not related to the address translation process. The
faults that are not reported when `DTF` is 1 are listed in <<FAULT_CAUSE>>.

[NOTE]
====
A hypervisor may set `DTF` to 1 to disable fault reporting when it has
identified conditions that may lead to a flurry of errors such as due to an
abnormal termination of a virtual machine.
====

The `fsc` field of `DC` holds the context for first-stage translations (S-stage
or VS-stage). If the `PDTV` bit is 1, the field holds the PPN of the root page
of PDT.  If the `PDTV` bit is 0 and `iohgatp.MODE` is `Bare`, the `fsc` field
holds the PPN of the root page of a S-stage page table (i.e. `iosatp`).
if the `PDTV` bit is 0 and `iohgatp.MODE` is not `Bare`, the `fsc` field holds
the PPN of the root page of a VS-stage page table (i.e. `iovsatp`).

The `PDTV` is expected to be set to 1 when `DC` is associated with a device
that supports multiple process contexts and thus generates a valid `process_id`
with its memory accesses. For PCIe, for example, if the request has a PASID
then the PASID is used as the `process_id`.

When `PDTV` is 1, the `DPE` bit may set to 1 to enable the use of 0 as the default
value of `process_id` for translating requests without a valid `process_id`.

When `PDTV` is 0, the `DPE` bit is reserved for future standard extension. Until
its use is defined, the bit should be cleared by software for forward
compatibility, and must be ignored by hardware.

If `GADE` is 1, the IOMMU updates A and D bits in G-stage PTEs atomically. If
`GADE` is 0, the IOMMU behavior is determined by G-stage A/D fault enable -
`GADFE` - control bit. If `GADFE` is 1 then the IOMMU causes a guest-page-fault.
If `GADFE` is 0, the IOMMU ignores the A and D bits in the PTEs; the IOMMU does
not update the A or D bits and does not cause any faults based on A and/or D
bit being 0.

If `SADE` is 1, the IOMMU updates A and D bits in S/VS-stage PTEs atomically. If
`SADE` is 0, the IOMMU behavior is determined by S/VS-stage A/D fault enable -
`SADFE` control bit. If `SADFE` is 1 then the IOMMU causes a page-fault. If
`SADFE` is 0, the IOMMU ignores the A and D bits in the PTEs; the IOMMU does
not update the A or D bits and does not cause any faults based on A and/or D bit
being 0.

The IOMMU supports the 1 setting of `GADE` and `SADE` bits if `capabilities.AMO`
is 1; else these bits are reserved. The IOMMU supports the 1 setting of `GADFE`
and `SADFE` if `capabilities.ADFE` is 1; else these bits are reserved.

If `SBE` is 0, implicit memory accesses to PDT entries and S/VS-stage PTEs are
little-endian else they are big-endian. The supported values of `SBE` are the
same as that of the `fctl.BE` field.

===== IO hypervisor guest address translation and protection (`iohgatp`)
The `iohgatp` field holds the PPN of the root G-stage page table and a
virtual machine identified by a guest soft-context ID (`GSCID`), to facilitate
address-translation fences on a per-virtual-machine basis. If multiple devices
are associated to a VM with a common G-stage page table, the hypervisor is
expected to program the same `GSCID` in each `iohgatp`. The `MODE` field is used
to select the G-stage address translation scheme.

The G-stage page table formats are as defined by the Privileged specification.

The `iohgatp` `MODE` field identifies the paged virtual-memory schemes and its
encodings are as follows:

[[IOHGATP_MODE_ENC]]
.Encoding of `iohgatp.MODE` field
[width=75%]
[%header, cols="3,3,20"]
|===
|Value | Name     | Description
| 0    | `Bare`   | No translation or protection.
| 1-7  | --       | Reserved for standard use.
| 8    | `Sv39x4` | Page-based 41-bit virtual addressing (2-bit extension
                    of Sv39).
| 9    | `Sv48x4` | Page-based 50-bit virtual addressing (2-bit extension
                    of Sv48).
| 10   | `Sv57x4` | Page-based 59-bit virtual addressing (2-bit extension
                    of Sv57).
| 11-14| --       | Reserved for standard use.
| 15    | `Sv32x4`| Page-based 34-bit virtual addressing (2-bit extension
                    of Sv32).
|===

Implementations are not required to support all defined mode settings for
`iohgatp`. The IOMMU only needs to support the modes also supported by the MMU
in the harts integrated into the system or a subset thereof.

The root page table as determined by `iohgatp.PPN` is 16 KiB and must be aligned
to a 16-KiB boundary.

[NOTE]
====
The `GSCID` field of `iohgatp` identifies an address space. Configuring
identical `GSCID` in two `DC` when the G-stage page-table referenced by the two
`DC` are not identical then it is unpredictable whether the IOMMU uses the
PTEs from the first page table or the second page table. These are the only
expected behaviors.
====

.IO hypervisor guest address translation and protection (`iohgatp`) field
[wavedrom, , ]
....
{reg: [
  {bits: 44, name: 'PPN'},
  {bits: 16, name: 'GSCID'},
  {bits: 4,  name: 'MODE'},
], config:{lanes: 2, hspace: 1024, fontsize: 16}}
....

===== Translation attributes (`ta`)

.Translation attributes (`ta`) field
[wavedrom, , ]
....
{reg: [
  {bits: 12, name: 'reserved'},
  {bits: 20, name: 'PSCID'},
  {bits: 32, name: 'reserved'},
], config:{lanes: 2, hspace: 1024, fontsize: 16}}
....

The `PSCID` field of `ta` provides the process soft-context ID that identifies
the address-space of the process. `PSCID` facilitates address-translation
fences on a per-address-space basis. The `PSCID` field in `ta` is used as the
address-space ID if `PDTV` is 0 and the `iosatp`/`iovsatp` `MODE` field is not
`Bare`. When `PDTV` is 1, the `PSCID` field in `ta` is ignored.

===== First-Stage context (`fsc`)
If `PDTV` is 0, the `fsc` field in `DC` holds the `iosatp` (when `iohgatp MODE`
is `Bare`) or the `iovsatp` (when `iohgatp MODE` is not `Bare`) that provide the
controls for S-stage page table or VS-stage address translation and protection
respectively.

.IO (Virtual)Supervisor addr. translation and prot. (`iovsatp`/`iosatp`) field (when `PDTV` is 0)
[wavedrom, , ]
....
{reg: [
  {bits: 44, name: 'PPN'},
  {bits: 16, name: 'reserved'},
  {bits: 4,  name: 'MODE'},
], config:{lanes: 2, hspace: 1024, fontsize: 16}}
....

The S/VS-stage page table formats are as defined by the Privileged
specification.

The `iosatp`/`iovsatp` `MODE` identifies the paged virtual-memory schemes and
is encoded as follows:

[[IOSATP_MODE_ENC]]
.Encodings of `iosatp/iovsatp.MODE` field
[width=75%]
[%header, cols="3,3,20"]
|===
|Value | Name     | Description
| 0    | `Bare`   | No translation or protection.
| 1-7  | --       | Reserved for standard use.
| 8    | `Sv39`   | Page-based 39-bit virtual addressing.
| 9    | `Sv48`   | Page-based 48-bit virtual addressing.
| 10   | `Sv57`   | Page-based 57-bit virtual addressing.
| 11-14| --       | Reserved for standard use.
| 15   | `Sv32`   | Page-based 32-bit virtual addressing.
|===

When `PDTV` is 1, the `fsc` field holds the process-directory table pointer
(`pdtp`). When the device supports multiple process contexts, selected by the
`process_id`, the PDT is used to determine the S/VS-stage page table and
associated `PSCID` for virtual address translation and protection.

The `pdtp` field holds the PPN of the root PDT and the `MODE` field that
determines the number of levels of the PDT.

.Process-directory table pointer (`pdtp`) field (when `PDTV` is 1)
[wavedrom, , ]
....
{reg: [
  {bits: 44, name: 'PPN'},
  {bits: 16, name: 'reserved'},
  {bits: 4,  name: 'MODE'},
], config:{lanes: 2, hspace: 1024, fontsize: 16}}
....

When two-stage address translation is active (`iohgatp.MODE != Bare`), the `PPN`
field holds a guest PPN.  The GPA of the root PDT is then converted by guest
physical address translation, as controlled by the `iohgatp`, into a supervisor
physical address. Translating addresses of root PDT root through G-stage page
tables, allows the PDT to be held in memory allocated by the guest OS and allows
the guest OS to directly edit the PDT to associate a virtual-address space
identified by a VS-stage page table with a `process_id`.

[[PDTP_MODE_ENC]]
.Encoding of `pdtp.MODE` field
[width=75%]
[%header, cols="3,3,20"]
|===
|Value | Name     | Description
| 0    | `Bare`   | No translation or protection. First stage translation is
                    not enabled.
| 1    | `PD8`    | 8-bit process ID enabled. The directory has 1 levels with
                    256 entries.The bits 19:8 of `process_id` must be 0.
| 2    | `PD17`   | 17-bit process ID enabled. The directory has 2 levels.
                    The root PDT page has 512 entries and leaf level has
                    256 entries. The bits 19:17 of `process_id` must be 0.
| 3    | `PD20`   | 20-bit process ID enabled. The directory has 3 levels.
                    The root PDT has 8 entries and the next non-leaf
                    level has 512 entries. The leaf level has 256 entries.
| 4-15 | --       | Reserved
|===

===== MSI page table pointer (`msiptp`)

The `msiptp` field holds the PPN of the root MSI page table used to direct an
MSI to a guest interrupt file in an IMSIC. The MSI page table format is defined
in <<MSI_PT>>.

The `MODE` field is used to select the MSI address translation scheme.

.MSI page table pointer (`msiptp`) field
[wavedrom, , ]
....
{reg: [
  {bits: 44, name: 'PPN'},
  {bits: 16, name: 'reserved'},
  {bits: 4,  name: 'MODE'},
], config:{lanes: 2, hspace: 1024, fontsize: 16}}
....

.Encoding of `msiptp` `MODE` field
[width=75%]
[%header, cols="3,3,20"]
|===
|Value | Name     | Description
| 0    | `Bare`   | No translation or protection. MSI recognition using
                    MSI address mask and pattern is not performed.
| 1    | `Flat`   | Flat MSI page table
|===

[[MSI_ID]]
===== MSI address mask (`msi_addr_mask`) and pattern (`msi_addr_pattern`)

The MSI address mask (`msi_addr_mask`) and pattern (`msi_addr_pattern`) fields
are used to recognize certain memory writes from the device as being MSIs and
to identify the 4-KiB pages of virtual interrupt files in the guest physical
address space of the relevant VM. An incoming 32-bit write made by a device is
recognized as an MSI write to a virtual interrupt file if the destination guest
physical page matches the supplied address pattern in all bit positions that are
zeros in the supplied address mask. In detail, a write to guest physical address
`A` is recognized as an MSI to a virtual interrupt file if:

`(A >> 12) & ~msi_addr_mask = (msi_addr_pattern & ~msi_addr_mask)`

where >> 12 represents shifting right by 12 bits, an ampersand (&) represents
bitwise logical AND, and `~msi_addr_mask` is the bitwise logical complement of
the address mask.

.MSI address mask (`msi_addr_mask`) field
[wavedrom, , ]
....
{reg: [
  {bits: 52, name: 'mask'},
  {bits: 12, name: 'reserved'},
], config:{lanes: 2, hspace: 1024, fontsize: 16}}
....
.MSI address pattern (`msi_addr_pattern`) field
[wavedrom, , ]
....
{reg: [
  {bits: 52, name: 'pattern'},
  {bits: 12, name: 'reserved'},
], config:{lanes: 2, hspace: 1024, fontsize: 16}}
....

[[DC_MISCONFIG]]
==== Device-context configuration checks

A `DC` with `V=1` is considered as misconfigured if any of the following
conditions are true.

. If any bits or encoding that are reserved for future standard use are set
  within `DC`, stop and report "DDT entry misconfigured" (cause = 259).
. `capabilities.ATS` is 0 and `DC.tc.EN_ATS`, or `DC.tc.EN_PRI`,
   or `DC.tc.PRPR` is 1
. `DC.tc.EN_ATS` is 0 and `DC.tc.T2GPA` is 1
. `DC.tc.EN_ATS` is 0 and `DC.tc.EN_PRI` is 1
. `DC.tc.EN_PRI` is 0 and `DC.tc.PRPR` is 1
. `capabilities.T2GPA` is 0 and `DC.tc.T2GPA` is 1
. `DC.tc.T2GPA` is 1 and `DC.iohgatp.MODE` is `Bare`
. `DC.tc.PDTV` is 1 and `DC.fsc.pdtp.MODE` is not a supported mode
.. `capabilities.PD20` is 0 and `DC.fsc.pdtp.MODE` is `PD20`
.. `capabilities.PD17` is 0 and `DC.fsc.pdtp.MODE` is `PD17`
.. `capabilities.PD8` is 0 and `DC.fsc.pdtp.MODE` is `PD8`
. `DC.tc.PDTV` is 0 and `DC.fsc.iosatp.MODE` is not one of the
   supported modes
.. `capabilities.Sv32` is 0 and `DC.fsc.iosatp.MODE` is `Sv32`
.. `capabilities.Sv39` is 0 and `DC.fsc.iosatp.MODE` is `Sv39`
.. `capabilities.Sv48` is 0 and `DC.fsc.iosatp.MODE` is `Sv48`
.. `capabilities.Sv57` is 0 and `DC.fsc.iosatp.MODE` is `Sv57`
. `capabilities.Sv32x4` is 0 and `DC.iohgatp.MODE` is `Sv32x4`
. `capabilities.Sv39x4` is 0 and `DC.iohgatp.MODE` is `Sv39x4`
. `capabilities.Sv48x4` is 0 and `DC.iohgatp.MODE` is `Sv48x4`
. `capabilities.Sv57x4` is 0 and `DC.iohgatp.MODE` is `Sv57x4`
. `capabilities.MSI_FLAT` is 1 and `DC.msiptp.MODE` is not `Bare`
   and not `Flat`
. `DC.iohgatp.MODE` is not `Bare` and the root page table determined by
  `DC.iohgatp.PPN` is not aligned to a 16-KiB boundary.
. `capabilities.AMO` is 0 and `DC.tc.SADE` or `DC.tc.GADE` is 1
. `capabilities.END` is 0 and `fctl.BE != DC.tc.SBE`

[NOTE]
====
Some `DC` fields that hold a system-physical-addresses or
guest-physical-addresses. Some implementations may verify the validity of the
addresses - e.g. the system-physical-address is not wider than that supported as
determined by `capabilities.PAS`, etc. at the time of locating the `DC`. Such
implementations may cause a "DDT entry misconfigured" (cause = 259) fault.

Other implementations only detect such addresses to be invalid when the data
structure referenced by these fields need to be accessed. Such
implementations may detect access-violation faults in the process of making the
access.
====

=== Process-Directory-Table (PDT)

The PDT is a 1, 2, or 3-level radix tree indexed using the process directory
index (`PDI`) bits of the `process_id`.

The following diagrams illustrate the PDT radix-tree. The root
process-directory page number is located using the process-directory-table
pointer (`pdtp`) field of the device-context. Each non-leaf (`NL`) entry
provides the PPN of the next level process-directory-table. The leaf
process-directory-table entry holds the process-context (`PC`).

.Three, two and single-level process directory
["ditaa",shadows=false, separation=false, font=courier, fontsize: 16]
....
  +-------+-------+-------+      +-------+-------+   +-------+
  |PDI[2] |PDI[1] |PDI[0] |      |PDI[1] |PDI[0] |   |PDI[0] |
  +--+----+--+----+--+----+      +-+-----+-+-----+   +-+-----+
     |       |       |             |       |           |
     +-3−bit +-9−bit +-8−bit       +-9−bit +-8−bit     +-8−bit
     |       |       |             |       |           |
     |  +--+ |  +--+ |  +--+       |  +--+ |  +--+     |   +--+
     |  |  | |  |  | |  |  |       |  |  | |  |  |     |   |  |
     |  |  | |  |  | |  +--+       |  |  | |  +--+     |   |  |
     |  |  | |  |  | +->|PC|       |  |  | +->|PC|     |   |  |
     |  |  | |  +--+    +--+       |  |  |    +--+     |   |  |
     |  |  | +->|NL+-+  |  |       |  +--+    |  |     |   |  |
     |  |  |    +--+ |  |  |       +->|NL+-+  |  |     |   +--+
     +->+--+    |  | |  |  |          +--+ |  |  |     +-->|PC|
        |NL+-+  |  | |  |  |          |  | |  |  |         +--+
        +--+ |  |  | |  |  |          |  | |  |  |         |  |
        |  | |  |  | |  |  |          |  | |  |  |         |  |
pdtp--->+--+ +->+--+ +->+--+  pdtp--->+--+ +->+--+ pdtp--->+--+
....

==== Non-leaf PDT entry

A valid (`V==1`) non-leaf PDT entry holds the PPN of the next-level PDT.

.Non-leaf process-directory-table entry

[wavedrom, , ]
....
{reg: [
  {bits:  1, name: 'V',        attr: '1'},
  {bits:  9, name: 'reserved', attr: '9'},
  {bits: 44, name: 'PPN',      attr: '44'},
  {bits: 10, name: 'reserved', attr: '10'},
], config:{lanes: 2, hspace:1024, fontsize: 16}}
....

==== Leaf PDT entry
The leaf PDT page is indexed by `PDI[0]` and holds the 16-byte process-context
(`PC`).

.Process-context

[wavedrom, , ]
....
{reg: [
  {bits: 64,  name: 'Translation-attributes (ta)'},
  {bits: 64,  name: 'First-stage-context (fsc)'},
], config:{lanes: 2, hspace: 1024, fontsize: 16}}
....

The `PC` is interpreted as two 64-bit doublewords. The byte order of each of the
doublewords in memory, little-endian or big-endian, is the endianness as
determined by `DC.tc.SBE`. The IOMMU may read the `PC` fields in any order.

==== Process-context fields

===== Translation attributes (`ta`)

.Translation attributes (`ta`) field
[wavedrom, , ]
....
{reg: [
  {bits: 1,  name: 'V',        attr: '1'},
  {bits: 1,  name: 'ENS',     attr: '1'},
  {bits: 1,  name: 'SUM',    attr: '1'},
  {bits: 9, name: 'reserved', attr: '9'},
  {bits: 20, name: 'PSCID',    attr: '20'},
  {bits: 32, name: 'reserved', attr: '32'},
], config:{lanes: 4, hspace: 1024, fontsize: 16}}
....

`PC` is valid if the `V` bit is 1; If it is 0, all other bits in `PC` are don't
care and may be freely used by software.

When Enable-Supervisory-access (`ENS`) is 1, transactions requesting supervisor
privilege are allowed with this `process_id` else the transaction is treated as
an unsupported request.

When `ENS` is 1, the `SUM` (permit Supervisor User Memory access) bit
modifies the privilege with which supervisor privilege transactions access
virtual memory. When `SUM` is 0, supervisor privilege transactions to pages
mapped with `U`-bit in PTE set to 1 will fault.

When `ENS` is 1, supervisor privilege transactions that read with execute
intent to pages mapped with `U` bit in PTE set to 1 will fault, regardless of
the state of `SUM`.

===== First-Stage context (`fsc`)
If `PDTV` is 0, the `fsc` field in `DC` holds the `iosatp` (when `iohgatp MODE`
is `Bare`) or the `iovsatp` (when `iohgatp MODE` is not `Bare`) that provide
the controls for S-stage page or VS-stage address translation and protection
respectively.

.IO (Virtual)Supervisor addr. translation and prot. (`iovsatp`/`iosatp`) field (when `PDTV` is 1)
[wavedrom, , ]
....
{reg: [
  {bits: 44, name: 'PPN'},
  {bits: 16, name: 'reserved'},
  {bits: 4,  name: 'MODE'},
], config:{lanes: 2, hspace: 1024, fontsize: 16}}
....

A valid (`V==1`) leaf PDT entry holds the PPN of the root page of a S/VS-stage
page table and the `MODE` used to determine the S/VS-stage address translation
scheme. The `MODE` field encoding are as defined for the `MODE` field in the
`satp`/`vsatp` CSR.

The software assigned process soft-context ID (`PSCID`) is used as the address
space ID for the process identified by the S/VS-stage page table.

When two-stage address translation is active (`iohgatp.MODE != Bare`), the `PPN`
field holds a guest PPN of the root of a VS-stage page table. Addresses of the
VS-stage page table entries are then converted by guest physical address
translation process, as controlled by the `iohgatp`, into a supervisor physical
address. A guest OS may thus directly edit the VS-stage page table to limit
access by the device to a subset of its memory and specify permissions for the
device accesses.

[NOTE]
====
The `PSCID` field of `PC` identified an address space. Configuring identical
`PSCID` in two `PC` when the page-table referenced by the two `PC` are not
identical then it is unpredictable whether the IOMMU uses the PTEs from the
first page table or the second page table. These are the only expected
behaviors.
====

[[PC_MISCONFIG]]
==== Process-context configuration checks

A `PC` with `V=1` is considered as misconfigured if any of the following
conditions are true.

. If any bits or encoding that are reserved for future standard use are set
  within `PC`, stop and report "PDT entry misconfigured" (cause = 267).
. `capabilities.Sv32` is 0 and `PC.fsc.MODE` is `Sv32`
. `capabilities.Sv39` is 0 and `PC.fsc.MODE` is `Sv39`
. `capabilities.Sv48` is 0 and `PC.fsc.MODE` is `Sv48`
. `capabilities.Sv57` is 0 and `PC.fsc.MODE` is `Sv57`

[NOTE]
====
Some `PC` fields that hold a system-physical-addresses or
guest-physical-addresses. Some implementations may verify the validity of the
addresses - e.g. the system-physical-address is not wider than that supported
as determined by `capabilities.PAS`, etc. at the time of locating the `PC`.
Such implementations may cause a "PDT entry misconfigured" (cause = 267) fault.

Other implementations only detect such addresses to be invalid when the data
structure referenced by these fields need to be accessed. Such implementations
may detect access-violation faults in the process of making the access.
====

[[MSI_PT]]
=== MSI page tables
Whenever an IOMMU recognizes an incoming write from a device as an MSI by the
method specified in the previous section, the MSI is translated or converted by
consulting the MSI page table configured for the device, instead of using the
regular translation data structures that apply to all other memory accesses from
the same device.

Only naturally aligned 32-bit writes from a device are possible MSIs. For other
forms of memory accesses by a device (such as reads, writes of other sizes, or
misaligned writes), the regular translation data structures are always applied,
even if the address matches that of a proper MSI.

An MSI page table is a flat array of MSI page table entries (MSI PTEs), each
16 bytes. MSI page tables have no multi-level hierarchy like regular RISC-V page
tables do. Rather, every MSI PTE is a leaf entry specifying the translation or
conversion of writes made to a particular 4-KiB guest physical page that a
virtual interrupt file occupies (or may occupy) in the relevant virtual machine.
To select an individual MSI PTE from an MSI page table, the PTE array is indexed
by the interrupt file number extracted from the destination guest physical
address of the incoming MSI write by the formula of the <<MSI_ID>>. Each
MSI PTE may specify either the address of a real guest interrupt file that
substitutes for the targeted virtual interrupt file (as in <<MSI_REDIR>>), or a
memory-resident interrupt file in which to store incoming MSIs for the virtual
interrupt file (as in <<MRIF_WRITE>>).

The number of entries in an MSI page table is always a power of two,
specifically `2^k^` where `k` is the number of bits that are ones in the MSI
address mask used to extract the interrupt file number from the destination
guest physical address. If an MSI page table has 256 or fewer entries, the
start of the table is always aligned to a 4-KiB page address in real
physical memory. If an MSI page table has `2^k^ > 256` entries, the table must
be naturally aligned to a `2k` × 16-byte address boundary.  If an MSI page table
is not aligned as required, all entries in the table appear to an IOMMU as
unspecified, and any address an IOMMU may compute and use for reading an
individual MSI PTE from the table is also unspecified.

Every 16-byte MSI PTE is interpreted as two 64-bit doublewords. The byte order 
for each of the two doublewords in memory, little-endian or big-endian, is the 
endianness as determined by `fctl.BE` (<<FCTRL>>).

Bit 0 of the first doubleword of an MSI PTE is field `V` (Valid). When `V = 0`,
the PTE is invalid, and all other bits of both doublewords are ignored by an
IOMMU, making them free for software to use.

If `V = 1`, bit 63 of the first doubleword is field `C` (Custom), designated for
custom use. If an MSI PTE has `V = 1` and `C = 1`, interpretation of the rest of
the PTE is `UNSPECIFIED`.

If `V = 1` and the custom-use bit `C = 0`, then bit 2 of the first doubleword
is field `W` (Write-through).  If `W = 1`, the MSI PTE specifies write-through
mode for incoming MSIs, and if `W = 0`, it specifies MRIF mode. The
interpretation of an MSI PTE for each of these two modes is detailed further
in the next two subsections.

==== MSI PTE, write-through mode
When an MSI PTE has fields `V = 1`, `C = 0`, and `W = 1` (write-through mode), the
PTE’s complete format is:

.MSI PTE, write-through mode
[wavedrom, , ]
....
{reg: [
  {bits: 1, name: 'V', attr: ['1']},
  {bits: 1, name: '0'},
  {bits: 1,  name: 'W', attr:['1']},
  {bits: 7,  name: '0'},
  {bits: 44,  name: 'PPN'},
  {bits: 9,  name: '0'},
  {bits: 1,  name: 'C', attr:['0']},
  {bits: 64,  name: 'ignored'},
], config:{lanes: 4, hspace: 1024, fontsize: 16}}
....

Reserved bits of the first doubleword must be set to zeros by software. The second
doubleword is ignored by an IOMMU so is free for software to use.

An incoming MSI write is translated by replacing the write’s original
address bits 12 and above (the guest physical page number) with field `PPN`
(Physical Page Number) from the PTE, while retaining the original address
bits 11:0 (the page offset). This translated address is either zero-extended
or clipped at the upper end as needed to make it the width of a real physical
address for the machine.

An MSI PTE in write-through mode allows a hypervisor to route an MSI intended
for a virtual interrupt file to go instead to a guest interrupt file of a
real IMSIC in the machine.

[NOTE]
====
An IOMMU can maximize the overlap between the handling of MSI PTEs and
regular RISC-V leaf PTEs as follows:

For RV64, the first doubleword of an MSI PTE in write-through mode has the
same encoding as a regular RISC-V leaf PTE for Sv39, Sv48, Sv39x4, or
Sv48x4 page-based address translation, with PTE fields D, A, G, U, X, and R
all zeros and W = 1. Hence, the MSI PTE’s first doubleword appears the same
as a regular PTE that grants write permission (W = 1) but not read or
execute permissions (X = R = 0). This same-encoded regular PTE would
translate an MSI write the same as the actual MSI PTE, except that what
would be the PTE’s accessed (A), dirty (D), and user (U) bits are all zeros.
An IOMMU needs to treat only these three bits differently for an MSI PTE
versus a regular RV64 leaf PTE.

The address computation used to select a PTE from a regular RISC-V page table
must be modified to select an MSI PTE’s first doubleword from an MSI page
table.  However, the extraction of an interrupt file number from a guest
physical address to obtain the index for accessing the MSI page table already
creates an unavoidable difference in PTE addressing. For RV32, the lower
32-bit word of an MSI PTE’s first doubleword has the same format as a leaf
PTE for Sv32 or Sv32x4 page-based address translation, except again for what
would be PTE bits A, D, and U, which must be treated differently.
====

[[MRIF_PTE]]
==== MSI PTE, MRIF mode

If memory-resident interrupt files are supported and an MSI PTE has fields
`V = 1`, `C = 0`, and `W = 0` (MRIF mode), the PTE’s complete format is:

.MSI PTE, MRIF mode
[wavedrom, , ]
....
{reg: [
  {bits: 1, name: 'V', attr: ['1']},
  {bits: 1, name: '0'},
  {bits: 1,  name: 'W', attr: ['0']},
  {bits: 4,  name: '0'},
  {bits: 47,  name: 'MRIF_ADDR[55:9]'},
  {bits: 9,  name: '0'},
  {bits: 1,  name: 'C', attr: ['0']},
  {bits: 10,  name: 'N90'},
  {bits: 44,  name: 'NPPN'},
  {bits: 6,  name: '0'},
  {bits: 1,  name: 'N10'},
  {bits: 3,  name: '0'},
], config:{lanes: 4, hspace: 1024, fontsize: 16}}
....

Reserved bits of the PTE must be set to zeros by software.

The PTEs `MRIF_ADDR[55:9]` field provides bits 55:9 of the physical address of a
memory-resident interrupt file in which to store incoming MSIs, referred
to as the destination MRIF. As every memory-resident interrupt file is
naturally aligned to a 512-byte address boundary, bits 8:0 of the
destination MRIFs address must be zero and are not specified in the PTE.

The `N10` field provides the bit 10 and the `N90` field provides the bits 9:0 of
a Notice Identifier (`NID`). Field `NPPN` (Notice Physical Page Number) and
the `NID` together specify a destination and value for a notice MSI that is sent
after each time the destination MRIF is updated as a result of consulting this
PTE to store an incoming MSI.

[NOTE]
====
Typically, `NPPN` will be the page address of an IMSICs interrupt file in the
real machine, and `NID` will be the interrupt identity to make pending in that
interrupt file to indicate that the destination MRIF may have changed. However,
`NPPN` is not required to be a valid interrupt file address, and an IOMMU must
not attempt to restrict it to only such addresses. Any page address must be
accepted for `NPPN`.
====

When the IMSIC interrupt files in the system implement memory-mapped register
`seteipnum_be` (See Advanced Interrupt Architecture) for receiving MSIs in
big-endian byte order, then an IOMMU must be able to store MSIs in both
little-endian and big-endian byte orders to the destination MRIF. If the IMSIC
interrupt files in the system do not implement register `seteipnum_be`, an
IOMMU should ordinarily store only little-endian MSIs to the destination MRIF.
The data of an incoming MSI is assumed to be in little-endian byte order if
bit 2 of the destination address is zero, and in big-endian byte order if bit
2 of the destination address is one.

[NOTE]
====
While IOMMUs are expected typically to cache MSI PTEs that are configured in
write-through mode (`W = 1`), they might not cache PTEs configured in MRIF mode
(`W = 0`). Two reasons together justify not caching MSI PTEs in MRIF mode: First,
the information and actions required to store an MSI to an MRIF are far
different than normal address translation; and second, by their nature, MSIs to
MRIFs should occur less frequently. Hence, an IOMMU might perform MRIF-mode
processing solely as an extension of cache-miss page table walks, leaving its
address translation cache oblivious to MRIF-mode MSI PTEs.

Software must not assume that an IOMMU may not cache MSI PTEs in MRIF mode and
perform suitable address translation cache invalidations when changing MSI PTEs.
====

===== Memory-resident interrupt files
An IOMMU may optionally support memory-resident interrupt files (MRIFs). If
implemented (`capabilities.MSI_MRIF = 1`, <<CAP>>), the use of memory-resident
interrupt files can greatly increase the number of virtual harts that can be
given direct control of one or more physical devices in a system, assuming the
rest of the system can still handle the added load.

Without memory-resident interrupt files, the number of virtual RISC-V harts that
can directly receive MSIs from devices is limited by the total number of guest
interrupt files implemented by all IMSICs in the system, because all MSIs to
RISC-V harts must go through IMSICs. For a single RISC-V hart, the number of
guest interrupt files is the `GEILEN` parameter defined by the Privileged
Architecture, which can be at most 31 for RV32 and 63 for RV64.  With the use of
memory-resident interrupt files, on the other hand, the total number of virtual
RISC-V harts able to receive device MSIs is almost unbounded, constrained only
by the amount of real physical memory and the additional processing time needed
to handle them. As its name implies, a memory-resident interrupt file is located
in memory instead of within an IMSIC. <<MRIF_WRITE>> depicts how an IOMMU can
record an incoming MSI in an MRIF. When properly configured by a hypervisor, an
IOMMU recognizes certain incoming MSIs as intended for a specific virtual
interrupt file, and records each such MSI by setting an interrupt-pending bit
stored within the MRIF data structure in ordinary memory. After each MSI is
recorded in an MRIF, the IOMMU also sends a notice MSI to the hypervisor to
inform it that the MRIF contents may have changed.

[[MRIF_WRITE]]
.Recording an MSI into a memory-resident interrupt file (MRIF)
["ditaa",shadows=false, separation=false, font=courier, fontsize: 16]
....
                                                                +---------------+
                                            +---------------+   | Main Memory   |
  +-------+   MSI     +-------+    set bit  |   IO Bridge   |   |  +----+       |
  |Device +---------->| IOMMU |----------------------------------->|MRIF|       |
  +-------+  Write    +-------+    (AMOOR)  |               |   |  +----+       |
                                            +---------------+   |               |
                                                                +---------------+
....

While a memory-resident interrupt file provides a place to record MSIs, it
cannot interrupt a hart directly the way an IMSIC’s guest interrupt files can.
The notice MSIs that hypervisors receive only indicate that a virtual hart might
need interrupting; a hypervisor is responsible for examining the MRIF contents
each time to determine whether actually to interrupt the virtual hart.
Furthermore, whereas an IMSIC’s guest interrupt file can directly act as a
supervisor-level interrupt file for a virtual hart, keeping a virtual hart’s
interrupt file in an MRIF while the virtual hart executes requires that the
hypervisor emulate a supervisor-level interrupt file for the virtual hart,
hiding the underlying MRIF. Depending on how often the virtual hart touches its
interrupt file and the implementation’s level of support for MRIFs, the cost of
this emulation may be significant. Consequently, MRIFs are expected most often
to be used for virtual harts that are more-or-less “swapped out” of a physical
hart due to being idle, or nearly so. When a hypervisor determines that an MSI
that landed in an MRIF should wake up a particular virtual hart that was idle,
the virtual hart can be assigned a guest interrupt file in an IMSIC and its
interrupt file moved from the MRIF into this guest interrupt file before the
virtual hart is resumed. The process of allocating a guest interrupt file for
the newly wakened virtual hart may of course force the interrupt file of
another virtual hart to be evicted to its own MRIF.

[NOTE]
====
Not all systems need to accommodate large numbers of idle virtual harts. Many
batch-processing servers, for example, strive to keep all virtual worker
threads as busy as possible from start to finish, throttled only by I/O delays
and limits on processing resources. In such environments, support for MRIFs
may not be useful, so long as parameter `GEILEN` is not too small.
====

An IOMMU can have one of these three levels of support for memory-resident
interrupt files:

[width=100%]
[%header, cols="^12,^12,20"]
|===
|`capabilities.MSI_MRIF` | `capabilities.AMO` | MRIF support level
|           0            |       0/1          | No MRIF
|           1            |       0            | MRIF without atomic update.
|           1            |       1            | MRIF with atomic update.
|===

Memory-resident interrupt files are most efficient when the memory system
supports logical atomic memory operations (AMOs) corresponding to RISC-V
instructions `AMOAND` and `AMOOR`, for memory accesses made both from harts and
from the IOMMU. The `AMOAND` and `AMOOR` operations are required for atomic
update of a memory-resident interrupt file. A reduced level of support is
possible without AMOs, relying solely on basic memory reads and writes.

A memory-resident interrupt file occupies 512 bytes of memory, naturally
aligned to a 512-byte address boundary. The 512 bytes are organized as an
array of 32 pairs of 64-bit doublewords, 64 doublewords in all. Each
doubleword is in little-endian byte order (even for systems where all
harts are big-endian-only).

[NOTE]
====
Big-endian-configured harts that make use of MRIFs are expected to
implement the `REV8` byte-reversal instruction defined Zbb extension.
If `REV8` is not implemented, then the endianness conversion may be
implemented using a sequence of instructions.
====

The pairs of doublewords contain the interrupt-pending and
interrupt-enable bits for external interrupt identities 1–2047, in this
arrangement:

[width=100%]
[%header, cols="^1,^1,6"]
|===
|offset | size (bytes) | contents
|0x000  |8             | interrupt-pending bits for (minor) identities 1–63
|0x008  |8             | interrupt-enable bits for identities 1–63
|0x010  |8             | interrupt-pending bits for identities 64–127
|0x018  |8             | interrupt-enable bits for identities 64–127
|. . .  |. . .         |...
|0x1F0  |8             | interrupt-pending bits for identities 1984–2047
|0x1F8  |8             | interrupt-enable bits for identities 1984–2047
|===


In general, the pair of doublewords at address offsets `k × 16` and
`k × 16 + 8` for integer `k` contain the interrupt-pending and interrupt-enable
bits for external interrupt minor identities in the range `k × 64` to
`k × 64 + 63`. For identity `i` in this range, bit (`i` mod 64) of the first
(even) doubleword is the interrupt-pending bit, and the same bit of the second
 (odd) doubleword is the interrupt-enable bit.

[NOTE]
====
The interrupt-pending and interrupt-enable bits are stored interleaved by
doublewords within an MRIF to facilitate the a future IOMMU extension examining
the relevant enable bit to determine whether to send a notice MSI after updating
a pending bit, rather than the current behavior of always sending a notice MSI
after an update without regard for the interrupt-enable bits. The memory
arrangement matters only when MRIFs are supported without atomic update.
====

Bit 0 of the first doubleword of an MRIF stores a faux interrupt-pending bit
for nonexistent interrupt 0. If a write from an I/O device appears to be an MSI
that should be stored in an MRIF, yet the data to write (the interrupt identity)
is zero, the IOMMU acts as though zero were a valid interrupt identity,
setting bit 0 of the target MRIF’s first doubleword and sending a notice MSI as
usual.

All MRIFs are the size to accommodate 2047 valid interrupt identities, the
maximum allowed for an IMSIC interrupt file. If a system’s actual IMSICs have
interrupt files that implement only `N` interrupt identities, `N` < 2047, then
the contents of MRIFs for identities greater than `N` may be ignored by software.
IOMMUs, however, treat every MRIF as though all interrupt identities in the range
0–2047 are valid, even as software ignores invalid identity 0 and all identities
greater than `N`.

[NOTE]
====
There is no need to specify to an IOMMU a desired size `N` for an MRIF smaller
than 2047 valid interrupt identities. The only use an IOMMU would make of this
information would be to discard any MSIs indicating an interrupt identity greater
than `N`. If devices are properly configured by software, such errant MSIs should
not occur; but even if they do, it is just as effective for software to ignore
spurious interrupt identities after they have been recorded in an MRIF as for an
IOMMU to discard them before recording them in the MRIF. It is likewise unnecessary
for IOMMUs to check for and discard MSIs indicating an invalid interrupt identity
of zero.
====

The data component of an MSI write specifies the interrupt identity to raise in
the destination interrupt file. (Recall <<MSI_REDIR>>) This data may be in
little-endian or big-endian byte order. If an IOMMU supports memory-resident
interrupt files, it can store to an MRIF MSIs of the same endianness that the
IOMMU is configured to operate in. All IMSIC interrupt files are required to
accept MSIs in little-endian byte order written to memory-mapped register
`seteipnum_le`. IMSIC interrupt files may also accept MSIs in big-endian byte
order if register `seteipnum_be` is implemented alongside `seteipnum_le`.
If the interrupt identity indicated by an MSI’s data (when interpreted in the
correct byte order) is in the range 0–2047, an IOMMU stores the MSI to an MRIF
by setting to one the interrupt-pending bit in the MRIF for that identity. If
atomic update is supported for MRIFs, the pending bit is set using an `AMOOR`
operation, else it is set using a non-atomic read-modify-write sequence. After
the interrupt-pending bit is set in the MRIF, the IOMMU sends the notice MSI
that software has configured for the MRIF. The exact process of storing an MSI
to an MRIF is specified more precisely in <<MSI_TRANS>>.

[[P2IOVA]]
=== Process to translate an IOVA

The process to translate an IOVA uses the hardware IDs (`device_id` and
`process_id`) to locate the Device-Context and the Process-Context. The
Device-context and Process-context provide the root PPN of the page tables,
`PSCID`, `GSCID`, and other control parameters that affect the address
translation and protection process. When address translation caches
(<<CACHING>>) are implemented, the translation process may use the `GSCID` and
`PSCID` to associate the cached translations with their address spaces.

The process to translate an `IOVA` is as follows:

. If `ddtp.iommu_mode == Off` then stop and report "All inbound transactions
  disallowed" (cause = 256).
. If `ddtp.iommu_mode == Bare` and any of the following conditions hold then
  stop and report "Transaction type disallowed" (cause = 260); else go to step
  21 with translated address same as the `IOVA`.
..  Transaction type is a Translated request (read, write/AMO, read-for-execute)
    or is a PCIe ATS Translation request.
. If `capabilities.MSI_FLAT` is 0 then the IOMMU uses base-format device
  context. Let `DDI[0]` be `device_id[6:0]`, `DDI[1]` be `device_id[15:7]`, and
  `DDI[2]` be `device_id[23:16]`.
. If `capabilities.MSI_FLAT` is 1 then the IOMMU uses extended-format device
  context. Let `DDI[0]` be `device_id[5:0]`, `DDI[1]` be `device_id[14:6]`, and
  `DDI[2]` be `device_id[23:15]`.
. The `device_id` is wider than that supported by the IOMMU mode if any of the
  following conditions hold. If the following conditions hold then stop and
  report "Transaction type disallowed" (cause = 260).
.. `ddtp.iommu_mode` is `2LVL` and `DDI[2]` is not 0
.. `ddtp.iommu_mode` is `1LVL` and either `DDI[2]` is not 0 or `DDI[1]` is not 0
. Use `device_id` to then locate the device-context (`DC`) as specified in
  <<GET_DC>>.
. if any of the following conditions hold then stop and report
  "Transaction type disallowed" (cause = 260).
..  Transaction type is a Translated request (read, write/AMO, read-for-execute)
    or is a PCIe ATS Translation request and `DC.tc.EN_ATS` is 0.
..  Transaction has a valid `process_id` and `DC.tc.PDTV` is 0.
..  Transaction has a valid `process_id` and `DC.tc.PDTV` is 1 and the
    `process_id` is wider than supported by `pdtp.MODE`.
..  Transaction type is not supported by the IOMMU.
. If request is a Translated request and `DC.tc.T2GPA` is 0 then the translation
  process is complete. Go to step 21.
. If request is a Translated request and `DC.tc.T2GPA` is 1 then the IOVA is a
  GPA. Go to step 17 with following page table information:
.. Let `A` be the `IOVA` (the `IOVA` is a GPA).
.. Let `iosatp.MODE` be `Bare`
... The `PSCID` value is not used when first-stage mode is `Bare`.
.. Let `iohgatp` be value in `DC.iohgatp` field
. If `DC.tc.PDTV` is set to 0 then go to step 17 with the following page table
  information:
.. Let `iosatp.MODE` be value in `DC.fsc.MODE` field
.. Let `iosatp.PPN` be value in `DC.fsc.PPN` field
.. Let `PSCID` be value in `DC.ta.PSCID` field
.. Let `iohgatp` be value in `DC.iohgatp` field
.. If a G-stage page table is not active in the device-context
     (`DC.iohgatp.mode` is `Bare`) then `iosatp` is a a S-stage page-table else
     it is a VS-stage page table.
. If `DPE` is 1 and there is no `process_id` associated with the transaction
  then let `process_id` be the default value of 0.
. If `DPE` is 0 and there is no `process_id` associated with the transaction
  then then go to step 17 with the following page table information:
.. Let `iosatp.MODE` be `Bare`
... The `PSCID` value is not used when first-stage mode is `Bare`.
. If `DC.fsc.pdtp.MODE = Bare` then go to step 17 with the following page table
  information:
.. Let `iosatp.MODE` be `Bare`
... The `PSCID` value is not used when first-stage mode is `Bare`.
.. Let `iohgatp` be value in `DC.iohgatp` field
. Locate the process-context (`PC`) as specified in <<GET_PC>>.
. if any of the following conditions hold then stop and report
  "Transaction type disallowed" (cause = 260).
..  The transaction requests supervisor privilege but `PC.ta.ENS` is not set.
. Go to step 17 with the following page table information:
.. Let `iosatp.MODE` be value in `PC.fsc.MODE` field
.. Let `iosatp.PPN` be value in `PC.fsc.PPN` field
.. Let `PSCID` be value in `PC.ta.PSCID` field
.. Let `iohgatp` be value in `DC.iohgatp` field
.. If a G-stage page table is not active in the device-context
   (`DC.iohgatp.mode` is `Bare`) then `iosatp` is a a S-stage page-table else
   it is a VS-stage page table.
. If a G-stage page table is not active in the device-context then use the
  single stage address translation process specified in Section 4.3.2 of the
  RISC-V privileged specification. If a fault is detecting by the single stage
  address translation process then stop and report the fault.
. If a G-stage page table is active in the device-context then use the
  two-stage address translation process specified in Section 8.5 of the RISC-V
  privileged specification to perform the VS-stage address translation to
  determine the GPA accessed by the transaction. If a fault is detecting by the
  two stage address translation process then stop and report the fault. If the
  translation process is completed then let `A` be the translated GPA.
. If all of the following conditions hold then MSI address translations using
  MSI page tables is enabled and the transaction is eligible for MSI address
  translation and the MSI address translation process specified in <<MSI_TRANS>>
  is invoked. If the GPA `A` is determined to be not an MSI then the process
  continues at step 20. If a fault is detected by the MSI address translation
  process then stop and report the fault.
.. Address `A` is a 32-bit aligned address.
.. Transaction is a Translated 32-bit write, Untranslated 32-bit write, or is
   an ATS translation request.
.. `DC.msiptp.MODE != Bare` i.e., MSI address translation using MSI page tables
   is enabled.
. If a G-stage page table is active in the device-context then use the
  G-stage address translation process specified in Section 8.5 of the RISC-V
  privileged specification to translate the GPA `A` to determine the SPA accessed
  by the transaction. If a fault is detecting by the two stage address translation
  process then stop and report the fault.
. Translation process is complete

When the translation process reports a fault, and the request is a Untranslated
request or a Translated request, the IOMMU requests the IO bridge to abort the
transaction. Guidelines for handling faulting transactions in the IO bridge are
provided in <<IOBR_FAULT_RESP>>. The fault may be reported using the fault/event
reporting mechanism and fault record formats specified in <<FAULT_QUEUE>>.

If the fault was detected by a PCIe ATS Translation Request then the IOMMU may
provide a PCIe protocol defined response instead of reporting fault to software
or causing an abort. The handling of faulting PCIe ATS Translation Requests is
specified in <<ATS_FAULTS>>.

[[GET_DC]]
==== Process to locate the Device-context

The process to locate the Device-context for transaction using its `device_id`
is as follows:

. Let `a` be `ddtp.PPN x 2^12^` and let `i = LEVELS - 1`. When
  `ddtp.iommu_mode` is `3LVL`, `LEVELS` is three. When `ddtp.iommu_mode` is
  `2LVL`, `LEVELS` is two. When `ddtp.iommu_mode` is `1LVL`, `LEVELS` is one.
. If `i == 0` go to step 8.
. Let `ddte` be value of eight bytes at address `a + DDI[i] x 8`. If accessing
  `ddte` violates a PMA or PMP check, then stop and report "DDT entry load
  access fault" (cause = 257).
. If `ddte` access detects a data corruption (a.k.a. poisoned data), then
  stop and report "DDT data corruption" (cause = 268).
. If `ddte.V == 0`, stop and report "DDT entry not valid" (cause = 258).
. If if any bits or encoding that are reserved for future standard use are
  set within `ddte`, stop and report "DDT entry misconfigured"
  (cause = 259).
. Let `i = i - 1` and let `a = ddte.PPN x 2^12^`. Go to step 2.
. Let `DC` be value of `DC_SIZE` bytes at address `a + DDI[0] * DC_SIZE`. If
  `capabilities.MSI_FLAT` is 1 then `DC_SIZE` is 64-bytes else it is 32-bytes.
  If accessing `DC` violates a PMA or PMP check, then stop and report
  "DDT entry load access fault" (cause = 257). If `DC` access detects a data
  corruption (a.k.a. poisoned data), then stop and report "DDT data corruption"
  (cause = 268).
. If `DC.tc.V == 0`, stop and report "DDT entry not valid" (cause = 258).
. If the `DC` is misconfigured as determined by rules outlined in
  <<DC_MISCONFIG>> then stop and report "DDT entry misconfigured" (cause = 259).
. The device-context has been successfully located and may be cached.

[[GET_PC]]
==== Process to locate the Process-context

The device-context provides the PDT root page PPN (`pdtp.ppn`).  When
`DC.iohgatp.mode` is not `Bare`, `pdtp.PPN` as well as `pdte.PPN` are Guest
Physical Addresses (GPA) which must be translated into Supervisor Physical
Addresses (SPA) using the G-stage page table pointed to by `DC.iohgatp`.
The memory accesses to the PDT are treated as implicit read memory accesses
by the G-stage page table.

The process to locate the Process-context for a transaction using its
`process_id` is as follows:

. Let `a` be `pdtp.PPN x 2^12^` and let `i = LEVELS - 1`. When
  `pdtp.MODE` is `PD20`, `LEVELS` is three. When `pdtp.MODE` is
  `PD17`, `LEVELS` is two. When `pdtp.MODE` is `PD8`, `LEVELS` is one.
. If `DC.iohgatp.mode != Bare`, then `a` is a GPA. Invoke the process
  to translate `a` to a SPA as an implicit memory access. If faults occur during
  G-stage address translation of `a` then stop and the fault detected by the
  G-stage address translation process. The translated `a` is used in subsequent
  steps.
. If `i == 0` go to step 9.
. Let `pdte` be value of eight bytes at address `a + PDI[i] x 8`. If
  accessing `pdte` violates a PMA or PMP check, then stop and report
  "PDT entry load access fault" (cause = 265).
. If `pdte` access detects a data corruption (a.k.a. poisoned data), then
  stop and report "PDT data corruption" (cause = 269).
. If `pdte.V == 0`, stop and report "PDT entry not valid" (cause = 266).
. If if any bits or encoding that are reserved for future standard use are
  set within `pdte`, stop and report "PDT entry misconfigured" (cause = 267).
. Let `i = i - 1` and let `a = pdte.PPN x 2^12`. Go to step 2.
. Let `PC` be value of 16-bytes at address `a + PDI[0] x 16`. If accessing `PC`
  violates a PMA or PMP check, then stop and report "PDT entry load access
  fault" (cause = 265). If `PC` access detects a data corruption
  (a.k.a. poisoned data), then stop and report "PDT data corruption"
  (cause = 269).
. If `PC.ta.V == 0`, stop and report "PDT entry not valid" (cause = 266).
. If the `PC` is misconfigured as determined by rules outlined in
  <<PC_MISCONFIG>> then stop and report "PDT entry misconfigured" (cause = 267).
. The Process-context has been successfully located.

[[MSI_TRANS]]
==== Process to translate addresses of MSIs

When an I/O device is configured directly by a guest operating system, MSIs
from the device are expected to be targeted to virtual IMSICs within the guest
OSs virtual machine, using guest physical addresses that are inappropriate
and unsafe for the real machine. An IOMMU must recognize certain incoming
writes from such devices as MSIs and convert them as needed for the real
machine.

MSIs originating from a single device that require conversion are expected
to have been configured at the device by a single guest OS running within one
RISC-V virtual machine. Assuming the VM itself conforms to the Advanced
Interrupt Architecture, MSIs are sent to virtual harts within the VM by writing
to the memory-mapped registers of the interrupt files of virtual IMSICs. Each of
these virtual interrupt files occupies a separate 4-KiB page in the VMs guest
physical address space, the same as real interrupt files do in a real machines
physical address space. A write to a guest physical address can thus be
recognized as an MSI to a virtual hart if the write is to a page occupied by
an interrupt file of a virtual IMSIC within the VM

When MSI address translation is supported (`capabilities.MSI_FLAT`, <<CAP>>),
the process to identify a incoming 32-bit aligned `IOVA` from a device as a MSI
address and translating the address using the MSI page table is as follows:

. Let `A` be the 32-bit aligned `GPA`
. Let `DC` be the device-context located using the `device_id` of the device
  using the process outlined in <<GET_DC>>.
. Determine if the address `A` is an MSI address as specified in <<MSI_ID>>.
. If the address is not determined to be an MSI then stop this process and
  instead use the regular translation data structures to do the address
  translation.
. Extract an interrupt file number `I` from `A` as
  `I = extract(A >> 12, DC.msi_addr_mask)`. The extract function here is similar
  to generic bit extract performed by RISC-V instruction `BEXT`, defined by the
  Zbs extension). The bit extract function `extract(x, y)`
  discards all bits from `x` whose matching bits in the same positions in the
  mask `y` are zeros, and packs the remaining bits from `x` contiguously at the
  least-significant end of the result, keeping the same bit order as `x` and
  filling any other bits at the most-significant end of the result with zeros.
  For example, if the bits of `x` and `y` are
** `x = a b c d e f g h`
** `y = 1 0 1 0 0 1 1 0`
** then the value of `extract(x, y)` has bits `0 0 0 0 a c f g`.

. Let `m` be `(DC.msiptp.PPN x 2^12^)`.
. Let `msipte` be the value of sixteen bytes at address `(m | (I x 16))`. If
  accessing `msipte` violates a PMA or PMP check, then stop and report
  "MSI PTE load access fault" (cause = 261).
. If `msipte` access detects a data corruption (a.k.a. poisoned data), then
  stop and report "MSI PT data corruption" (cause = 270).
. If `msipte.V == 0`, then stop and report "MSI PTE not valid" (cause = 262).
. If `msipte.C == 1`, then further process is to interpret the PTE is
  implementation defined.
. If `msipte.C == 0` then the process is outlined in subsequent steps.
. If `msipte.W == 1` the PTE is write-through mode PTE and the translation
  process is as follows:
.. If any bits or encoding that are reserved for future standard use are set
   within `msipte`, stop and report "MSI PTE misconfigured" (cause = 263).
.. Compute the translated address as `msipte.PPN << 12 | A[11:0]`.
. If `msipte.W == 0` the PTE is in MRIF mode and the translation process
  is as follows:
.. If `capabilities.MSI_MRIF == 0`, stop and report "MSI PTE misconfigured"
   (cause = 263).
.. If any bits or encoding that are reserved for future standard use are
   set within `msipte`, stop and report "MSI PTE misconfigured" (cause = 263).
.. If the transaction is a PCIe ATS translation request then return a Success
   response with R, W, and U bit set to 1. See <<ATS_FAULTS>> for further
   details on this processing.
.. Let `D` be the 32-bit data associated with the write. The byte order of
   `D` is determined by bit 2 of `A`.
.. If bit 2 of `A` is 1, i.e. the MSI is in big-endian byte order. If big-endian
   MSIs are not supported by the IOMMU then stop and report "Transaction type
   disallowed" (cause = 260).
.. If `A[11:3]` or `D[31:11]` is not zero, then stop and report "Transaction
   type disallowed" (cause = 260).
.. If the IOMMU supports atomic memory operations
   (`capabilities.AMO` is 1, <<CAP>>), then, in the destination MRIF
   (at address `msipte.MRIF_ADDR[55:9] * 512`), set the interrupt-pending bit
   for interrupt identity `D` to 1 using an `AMOOR` operation for atomic update.
.. If the IOMMU does not support atomic memory operations then, in the
   destination MRIF (at address `msipte.MRIF_ADDR[55:9] * 512`), set the
   interrupt-pending bit for interrupt identity `D` to 1 using a non-atomic
   read-modify-write sequence.
.. If accessing MRIF violates a PMA or PMP check, then stop and report
   "MRIF access fault" (cause = 264).
.. If the MRIF access detects a data corruption (a.k.a poisoned data), then
   stop and report "MSI MRIF data corruption" (cause = 271).
.. Zero-extend the 11-bit `(msipte.N10 << 10) | msipte.N90` value to 32 bits,
   and do a 32-bit write of this value in little-endian byte order to the
   address `msipte.NPPN << 12` (i.e., physical page number `NPPN`, page
   offset zero).
.. The following rules must be followed to order the write to the destination
   MRIF and the write to the notice physical page number (`NPPN`):
... All writes older than the incoming MSI that was transformed by this
    process must be globally visible before the write to the destination
    MRIF or to the `NPPN` becomes globally visible; unless protocol specific
    relaxation is allowed (e.g. PCIe relaxed ordering) or is not required.
... The write to destination MRIF must be globally visible before the write to
    `NPPN` becomes globally visible.
. MSI address translation process is complete.

=== IOMMU updating of PTE accessed (A) and dirty (D) updates

When `capabilities.AMO` is 1, the IOMMU supports updating the A and D bits in
PTEs atomically. When updating of A and D bits in G-stage PTEs is enabled
(`DC.tc.GADE=1`) and/or updating of A and D bits in S/VS-stage PTEs is enabled
(`DC.tc.SADE=1`) the following rules apply:

. The A and/or D bit updates by the IOMMU must follow the rules specified by the
  Privileged specification for validity, permission checking, and atomicity.

. The PTE update must be globally visible before a memory access using the
  translated address provided by the IOMMU becomes globally visible.u
  Specifically, when a translated address is provided to a device in an ATS
  Translation completion, the PTE update must be globally visible before a
  memory access from the device using the translated address becomes globally
  visible.

[NOTE]
====
The A and D bits are never cleared by the IOMMU. If the supervisor software does
not rely on accessed and/or dirty bits, e.g. if it does not swap memory pages to
secondary storage or if the pages are being used to map I/O space, it should
set them to 1 in the PTE to improve performance.
====

=== Faults from virtual address translation process

Faults detected during the S-stage or two-stage address translation specified
in the privileged specification cause the IOVA translation process to stop and
report the detected fault.

[[ATS_FAULTS]]
=== PCIe ATS translation request handling
ATS translation requests that encounter a configuration error results in a
Completer Abort (CA) response to the requester. The following cause codes
belong to this category:

* Instruction access fault (cause = 1)
* Read access fault (cause = 5)
* Write/AMO access fault (cause = 7)
* MSI PTE load access fault (cause = 261)
* MSI PTE misconfigured (cause = 263)
* PDT entry load access fault (cause = 265)
* PDT entry misconfigured (cause = 267)

If there is a permanent error or if ATS transactions are disabled then a
Unsupported Request (UR) response is generated. The following cause codes
belong to this category:

* All inbound transactions disallowed (cause = 256)
* DDT entry load access fault (cause = 257)
* DDT entry not valid (cause = 258)
* DDT entry misconfigured (cause = 259)
* Transaction type disallowed (cause = 260)

When translation could not be completed due to following causes a Success
Response with R and W bits set to 0 is generated. No faults are logged in
the fault queue on these error. The translated address returned with such
completions is `UNSPECIFIED`.

* Instruction page fault (cause = 12)
* Read page fault (cause = 13)
* Write/AMO page fault (cause = 15)
* Instruction guest page fault (cause = 20)
* Read guest-page fault (cause = 21)
* Write/AMO guest-page fault (cause = 23)
* PDT entry not valid (cause = 266)
* MSI PTE not valid (cause = 262)

If the translation request has a PASID with "Privilege Mode Requested" field set
to 0, or the request does not have a PASID then the request does not target
privileged memory. If the U-bit that indicates if the memory is accessible to
user mode is 0 then a Success response with R and W bits set to 0 is generated.

If the translation request has a PASID with "Privilege Mode Requested" field set
to 1, then the request targets privileged memory. If the U-bit that indicates if
the page is accessible to user mode is 1 and the `SUM` bit in `ta` field of the
process-context is 0 then a Success response with R and W bits set to 0 is
generated.

If the translation could be successfully completed but the requested
permissions are not present (Execute requested but no execute permission;
no-write not requested and no write permission; no read permission)
then a Success response is returned with the denied permission (R, W or X)
set to 0 and the other permission bits set to value determined from the
page tables. The X permission is granted only if the R permission is also
granted. Execute-only translations are not compatible with PCIe ATS as PCIe
requires read permission to be granted if the execute permission is granted.

When a Success response is generated for a ATS translation request, no fault
records are reported to software through the fault/event reporting mechanism;
even when the response indicates no access was granted or some permissions were
denied.

If the translation request has an address determined to be an MSI address using
the rules defined by the <<MSI_ID>> but the MSI PTE is configured in MRIF
mode then a Success response is generated with R, W, and U bit set to 1. The U
bit being set to 1 in the response instructs the device that it must only use
Untranslated requests to access the implied 4 KiB memory range.

[NOTE]
====
When a MSI PTE is configured in MRIF mode, a MSI write with data value `D`
requires the IOMMU to set the interrupt-pending bit for interrupt identity `D`
in the MRIF. A translation request from a device to a GPA that is mapped
through a MRIF mode MSI PTE is not eligible to receive a translated address.
This is accomplished by setting "Untranslated Access Only" (U) field of the
returned response to 1.
====

When a Success response is generated for a ATS translation request, the setting
of the Priv, N, CXL.io, Global, and AMA fields is as follows:

* Priv field of the ATS translation completion is always set to 0 if the request
  does not have a PASID. When a PASID is present then the Priv field is set to
  the value in "Privilege Mode Requested" field as the permissions provided
  correspond to those the privilege mode indicate in the request.
* N field of the ATS translation completion is always set to 0. The device may
  use other means to determine if the No-snoop flag should be set in the
  translated requests.
* Global field is set to the value determined from the S/VS-stage page tables
  if translation could be successfully completed and the request had a PASID
  preset. In all other cases, including MSI address translations, this field
  is set to 0.
* If requesting device is not a CXL device then CXL.io is set to 0.
* If requesting device is a CXL type 1 or type 2 device
** If the address is determined to be a MSI then the CXL.io bit is set to 1.
** If the memory type, as determined by the Svpbmt extension, is NC or IO then
   the CXL.io bit is set to 1. If the memory type is PMA then the determination
   of the setting of this bit is `UNSPECIFIED`. If the Svpbmt extension is not
   supported then the setting of this bit is `UNSPECIFIED`.
** In all other cases the setting of this bit is `UNSPECIFIED`.
* The AMA field is by default set to 000b. The IOMMU may support an
  implementation specific method to provide other encodings.

[NOTE]
====
The IO bridge may override the CXL.io bit in the ATS translation completion
based on the PMA of the translated address. Other implementations may provide
an implementation-defined method for determining PMA for the translated address
to set the CXL.io bit.
====


[[ATS_PRI]]
=== PCIe ATS Page Request handling
To process a "Page Request" or "Stop Marker" message, the IOMMU first locates
the device-context to determine if ATS and PRI are enabled for the requestor.
If ATS and PRI are enabled, i.e. `EN_ATS` and `EN_PRI` are both set to 1, the
 IOMMU queues the message into an in-memory queue called the
page-request-queue (`PQ`) (See <<PRQ>>). Following suitable processing of the
"Page Request", a software handler may generate a "Page Request Group Response"
message to the device.

When PRI is enabled for a device, the IOMMU may still be unable to report
"Page Request" or "Stop Marker" messages through the `PQ` due to error
conditions such as the queue being disabled, queue being full, or the IOMMU
encountering access faults when attempting to access queue memory. These error
conditions are specified in <<PRQ>>.

If the `ddtp.iommu_mode` is `Bare` or is `Off`, then the IOMMU cannot locate a
device-context for the requestor.

If `EN_PRI` is set to 0, or `EN_ATS` is set to 0, or if the IOMMU is unable
to locate the `DC` to determine the `EN_PRI` configuration, or the request
could not be queued into `PQ` then the IOMMU behavior depends on the type
of "Page Request".

* If the "Page Request" does not require a response, i.e. the "Last Request in
  PRG" field of the message is set to 0, then such message are silently
  discarded. "Stop Marker" messages do not require a response and are always
  silently discarded on such errors.
* If the "Page Request" needs a response, then the IOMMU itself may generate
  a "Page Request Group Response" message to the device.

When the IOMMU generates the response, the status field of the response depends
on the cause of the error.

The status is set to Response Failure if the following faults are encountered:

* `ddtp.iommu_mode` is `Off`
* DDT entry load access fault (cause = 257)
* DDT entry misconfigured (cause = 259)
* DDT entry not valid (cause = 258)
* Page-request queue is not enabled (`pqcsr.pqen == 0` or `pqcsr.pqon == 0`)
* Page-request queue encountered a memory access fault (`pqcsr.pqmf == 1`)

The status is set to Invalid Request if the following faults are encountered:

* `ddtp.iommu_mode` is `Bare`
* `EN_PRI` is set to 0

The status is set to Success if no other faults were encountered but the
"Page Request" could not be queued due to the page-request queue being full
(`pqh == pqt - 1`) or had a overflow (`pqcsr.pqof == 1`).

[NOTE]
====
When SR-IOV VF is used as an unit of allocation, a hypervisor may disable page
requests from one of the virtual functions by setting `EN_PRI` to 0. However the
page-request interface is shared by the PF and all VFs.  The IOMMU protocol
specific logic classifies this condition (cause = 260) as a non-catastrophic
failure, an Invalid Request, in its response to avoid the shared PRI in the
device being disabled for all PFs/VFs.
====

[NOTE]
====
A "Stop Marker" is encoded as a "Page Request" with a PASID but with the L, W,
and R fields set to 1, 0, and 0 respectively.
====

For IOMMU generated "Page Request Group Response" messages that have status
Invalid Request or Success, the PRG-response-PASID-required (`PRPR`) bit when
set to 1 indicates that the IOMMU response message should include a PASID if the
associated "Page Request" had a PASID.

For IOMMU generated "Page Request Group Response" with response code set to
Response Failure, if the "Page Request" had a PASID then response is generated
with a PASID.

No faults are logged in the fault queue for PCIe ATS "Page Request" messages for
following conditions:

* Page-request queue is not enabled (`pqcsr.pqen == 0` or `pqcsr.pqon == 0`)
* Page-request queue encountered a memory access fault (`pqcsr.pqmf == 1`)
* "Page Request" could not be queued due to the page-request queue being full
  (`pqh == pqt - 1`) or had a overflow (`pqcsr.pqof == 1`).

[[CACHING]]
=== Caching in-memory data structures

To speed up Direct Memory Access (DMA) translations, the IOMMU may make use of
translation caches to hold entries from device-directory-table,
process-directory-table, S/VS and G-stage translation tables, MSI page
tables. These caches are collectively referred to as the IOMMU Address
Translation Caches (IOATC).

This specification does not allow the caching of S/VS/G-stage PTEs whose `V`
(valid) bit is clear, non-leaf DDT entries whose `V` (valid) bit is clear,
Device-context whose `V` (valid) bit is clear, non-leaf PDT entries whose `V`
(valid) bit is clear, Process-context whose `V` (valid) bit is clear, or MSI
PTEs whose `V` bit is clear.

These IOATC do not observe modifications to the in-memory data structures using
explicit loads and stores by RISC-V harts or by device DMA. Software must use
the IOMMU commands to invalidate the cached data structure entries using IOMMU
commands to synchronize the IOMMU operations to observe updates to in-memory
data structures. A simpler implementation may not implement IOATC for some or
any of the in-memory data structures. The IOMMU commands may use one or
more IDs to tag the cached entries to identify a specific entry or a
group of entries.

.Identifiers used to tag IOATC entries
[width=90%]
[%header, cols="8,10,10"]
|===
|Data Structure cached  |IDs used to tag entries    | Invalidation command
|Device Directory Table |`device_id`                | <<IDDT, IODIR.INVAL_DDT>>
|Process Directory Table|`device_id`, `process_id`  | <<IPDT, IODIR.INVAL_PDT>>
|VS-stage page tables   |`GSCID`, `PSCID`, and IOVA | <<IVMA, IOTINVAL.VMA>>
|S-stage page tables    |`PSCID`, and IOVA          | <<IVMA, IOTINVAL.VMA>>
|G-stage page table     |`GSCID`, `GPA`             | <<IGVMA,IOTINVAL.GVMA>>
|MSI page table         |`GSCID`, `GPA`             | <<IGVMA,IOTINVAL.GVMA>>
|===

=== Updating in-memory data structure entries

The RISC-V memory model requires memory access from a hart to be single-copy
atomic. When RV32 is implemented the size of a single-copy atomic memory access
is up to 32-bits when RV64 is implemented the size of a single-copy atomic
memory access is up to 64-bits. The size of a single-copy atomic memory access
implemented by the IOMMU is `UNSPECIFIED` but is required to be at least 32-bits
when the harts in the system implement RV32 and is required to be 64-bits when
the harts in the system implement RV64.

The IOMMU data structure entries have a `V` bit that when set to 1 indicates
that the entry is valid.

Software is allowed to make updates to a data structure entry that has the `V`
bit set to 1. However, some rules as outlined below must be followed.

* It is generally unsafe for software to update fields of a valid data structure
  entry using a set of stores of width less than the minimal single-copy atomic
  memory access supported by an IOMMU as it is legal for an IOMMU to read the
  entry at any time, including when only some of the partial stores have taken
  effect. +
+
* For an update to an IOMMU data structure entry to be atomic, software must use
  a single store of width equal to the minimal single-copy atomic memory access
  supported by an IOMMU. +
+
* If the update to a field will make the field inconsistent with another field
  of the entry then software must first set `V` field to 0 and use the commands
  outlined in <<CACHING>> to invalidate any previous copies of that entry that
  may be in IOMMU caches before updating other fields of that entry. +
+
* The IOMMU is not required to immediately observe the software update to an
  entry. Software must use the commands outlined in <<CACHING>> to invalidate
  any previous copies of that entry that may be in IOMMU caches to synchronize
  the updates to the entry with the operation of the IOMMU.

[NOTE]
====
If a data structure entry is changed, the IOMMU may use the old value of the
entry or the new value of the entry and the choice is unpredictable till
software uses the commands outlined in <<CACHING>> to invalidate any previous
copies of that entry that may be in IOMMU caches to synchronize updates to the
entry with the operation of the IOMMU. These are the only behaviors expected.
====

=== Endianness of in-memory data structures

The RISC-V memory model specifies byte-invariance for the entire address space.
When mixed-endian mode of operation is supported, the IO bridge and the IOMMU
must implement byte-invariant addressing such that a byte access to a given
address accesses the same memory location in both little-endian and big-endian
mode of operation.

The endianness of implicit memory access to in-memory data structures is
determined by `fctl.BE` or by `DC.tc.SBE` as follows:

[[ENDIAN_CONFIG]]
.Endianness of memory access to data structures
[width=75%]
[%header, cols="16,4"]
|===
^|Data Structure             ^| Controlled by
| Device directory table     | `fctl.BE`
| G-stage page table         | `fctl.BE`
| MSI page table             | `fctl.BE`
| Process directory Table    | `DC.tc.SBE`
| S/VS-stage page table      | `DC.tc.SBE`
|===

[NOTE]
====
The `PSCID` field of first-stage context, along with the `GSCID` (when two-stage
address translation is active), identifies an address space. Configuring an
identical `GSCID` and `PSCID` in two DC but with different `SBE` is not expected
and if done may lead to the IOMMU interpreting a S/VS-stage PTE as big-endian
or little-endian. These are the only behaviors are expected.
====

[NOTE]
====
Software must use an appropriate software sequence to swap bytes as necessary to
create a mutually agreed to data representation when sharing data with an IO
agent that does not share its endianness. Software must use an LR/SC sequence to
perform atomic operations in non-native endian format when the data shared with
such IO agents must be accessed atomically.
====
