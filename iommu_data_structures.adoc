[[DATA_STRUCTURES]]
== Data Structures
A data structure called device-context (`DC`) is used by the IOMMU to associate
a device with an address space and to hold other per-device parameters used
by the IOMMU to perform address translations. A radix-tree data structure called
device directory table (DDT) that is traversed using the `device_id` is used to
locate the `DC`.

The address space used by a device may require single-stage or two-stage address
translation and protection. Two-stage address translation may be required when the
control of the device is passed through to a Guest OS. Single-stage address
translation using a S-stage page table may be used when the control of the
device is retained by the hypervisor or Host OS itself.

When two-stage address translation is used the `DC` holds the PPN of the root
G-stage page table; a guest-soft-context-ID (`GSCID`), which facilitates
invalidation of cached address translations on a per-virtual-machine basis; and
the G-stage address translation scheme.

Some devices support multiple contexts where each context may be associated
with a different process and thus a different virtual address space. The context
in such devices may be configured with a `process_id` that identifies the
address space. When making a memory access, such devices signal the `process_id`
along with the `device_id` to identify the accessed address space. An example of
such a device is a GPU that supports multiple process contexts, where each
context is associated with a different user process, such that the GPU may
access memory using the virtual address provided by the user process itself. To
support selecting an address space associated with the `process_id`, the `DC`
holds the PPN of the root Process Directory Table (PDT), a radix-tree data
structure, indexed using fields of the `process_id` to locate a data structure
called the Process Context (`PC`).

When a PDT is active, the controls for S-stage or VS-stage address translation
are held in the (`PC`).

When a PDT is not active, the controls for S-stage or VS-stage address
translation are be held in the `DC` itself.

The S/VS-stage address translation controls include the PPN of the root
S/VS-stage page table; a process-soft-context-ID (`PSCID`), which facilitates
invalidation of cached address translations on a per-address-space basis; and
the S/VS-stage address translation scheme.

To handle MSIs from a device controlled by a guest OS, an IOMMU must be able to
redirect those MSIs to a guest interrupt file in an IMSIC. Because MSIs from
devices are simply memory writes, they would naturally be subject to the same
address translation that an IOMMU applies to other memory writes. However,
the IOMMU architecture may treat MSIs directed to virtual machines specially, in
part to simplify software, and in part to allow optional support for
memory-resident interrupt files. To support this capability, the architecture
adds to the device contexts an MSI address mask and address pattern, used together
to identify pages in the guest physical address space that are the destinations
of MSIs; and the real physical address of an MSI page table for controlling the
translation and/or conversion of MSIs from the device. The IOMMU support for
MSIs to virtual machines is specified by the Advanced Interrupt Architecture
specification.

The `DC` further holds controls for the type of transactions that a device is
allowed to generate. One example of such a control is whether the device is
allowed to use the PCIe defined Address Translation Service (ATS) cite:[PCI].

Two formats of the device-context structure are supported:

* *Base Format* - is 32-bytes in size used when the special treatment of MSI
  as specified in <<MSI_TRANS>> is not supported by the IOMMU.

* *Extended Format* - is 64-bytes in size and extends the base format `DC` with
  additional fields to translate MSIs as specified in <<MSI_TRANS>>.

If `capabilities.MSI_FLAT` is 1 then the Extended Format is used else the Base
Format is used.

The DDT used to locate the `DC` may be configured to be a 1, 2, or 3 level
radix-table depending on the maximum width of the `device_id` supported. The
partitioning of the `device_id` to obtain the device directory indexes (DDI) to
traverse the DDT radix-tree table are as follows:

.Base format `device_id` partitioning

[wavedrom, , ]
....
{reg: [
  {bits: 7, name: 'DDI[0]'},
  {bits: 9, name: 'DDI[1]'},
  {bits: 8, name: 'DDI[2]'},
], config:{lanes: 1, hspace:1024, fontsize: 16}}
....

.Extended format `device_id` partitioning

[wavedrom, , ]
....
{reg: [
  {bits: 6, name: 'DDI[0]'},
  {bits: 9, name: 'DDI[1]'},
  {bits: 9, name: 'DDI[2]'},
], config:{lanes: 1, hspace:1024, fontsize: 16}}
....

The PDT may be configured to be a 1, 2, or 3 level radix table depending on the
maximum width of the `process_id` supported for that device.  The partitioning
of the `process_id` to obtain the process directory indices (PDI) to traverse
the PDT radix-tree table are as follows:

.`process_id` partitioning for PDT radix-tree traversal

[wavedrom, , ]
....
{reg: [
  {bits: 8, name: 'PDI[0]'},
  {bits: 9, name: 'PDI[1]'},
  {bits: 3, name: 'PDI[2]'},
], config:{lanes: 1, hspace:1024, fontsize: 16}}
....
[NOTE]
====
The `process_id` partitioning is designed to require a maximum of 4 KiB, a
page, of memory for each process directory table. The root of the table when
using a 20-bit wide `process_id` is not fully populated. The option of making
the root table occupy 32 KiB was considered but not adopted as these tables
are allocated at run time and contiguous memory allocation larger than a page
may stress the Guest and hypervisor memory allocators.
====

[NOTE]
====
All RISC-V IOMMU implementations are required to support DDT and PDT located
in main memory. Supporting data structures in I/O memory is not required but
is not prohibited by this specification.
====

=== Device-Directory-Table (DDT)
DDT is up to 3-level radix tree indexed using the device directory index (DDI)
bits of the `device_id`.

The following diagrams illustrate the DDT radix-tree. The PPN of the root
device-directory-table is held in a memory-mapped register called the
device-directory-table pointer (`ddtp`).

Each valid non-leaf (`NL`) entry is 8-bytes in size and holds the PPN of the
next device-directory-table.

A valid leaf device-directory-table entry holds the device-context (`DC`).

.Three, two and single-level device directory with extended format `DC`
["ditaa",shadows=false, separation=false, font=courier, fontsize: 16]
....
  +-------+-------+-------+      +-------+-------+    +-------+
  |DDI[2] |DDI[1] |DDI[0] |      |DDI[1] |DDI[0] |    |DDI[0] |
  +--+----+--+----+--+----+      +-+-----+-+-----+    +-+-----+
     |       |       |             |       |            |
     +-9−bit +-9−bit +-6−bit       +-9−bit +-6−bit      +-6−bit
     |       |       |             |       |            |
     |  +--+ |  +--+ |  +--+       |  +--+ |  +--+      |   +--+
     |  |  | |  |  | |  |  |       |  |  | |  |  |      |   |  |
     |  |  | |  |  | |  +--+       |  |  | |  +--+      |   |  |
     |  |  | |  |  | +->|DC|       |  |  | +->|DC|      |   |  |
     |  |  | |  +--+    +--+       |  |  |    +--+      |   |  |
     |  |  | +->|NL+-+  |  |       |  +--+    |  |      |   |  |
     |  |  |    +--+ |  |  |       +->|NL+-+  |  |      |   +--+
     +->+--+    |  | |  |  |          +--+ |  |  |      +-->|DC|
        |NL+-+  |  | |  |  |          |  | |  |  |          +--+
        +--+ |  |  | |  |  |          |  | |  |  |          |  |
        |  | |  |  | |  |  |          |  | |  |  |          |  |
ddtp--->+--+ +->+--+ +->+--+  ddtp--->+--+ +->+--+  ddtp--->+--+
....

.Three, two and single-level device directory with base format `DC`
["ditaa",shadows=false, separation=false, font=courier, fontsize: 16]
....
  +-------+-------+-------+      +-------+-------+    +-------+
  |DDI[2] |DDI[1] |DDI[0] |      |DDI[1] |DDI[0] |    |DDI[0] |
  +--+----+--+----+--+----+      +-+-----+-+-----+    +-+-----+
     |       |       |             |       |            |
     +-8−bit +-9−bit +-7−bit       +-9−bit +-7−bit      +-7−bit
     |       |       |             |       |            |
     |  +--+ |  +--+ |  +--+       |  +--+ |  +--+      |   +--+
     |  |  | |  |  | |  |  |       |  |  | |  |  |      |   |  |
     |  |  | |  |  | |  +--+       |  |  | |  +--+      |   |  |
     |  |  | |  |  | +->|DC|       |  |  | +->|DC|      |   |  |
     |  |  | |  +--+    +--+       |  |  |    +--+      |   |  |
     |  |  | +->|NL+-+  |  |       |  +--+    |  |      |   |  |
     |  |  |    +--+ |  |  |       +->|NL+-+  |  |      |   +--+
     +->+--+    |  | |  |  |          +--+ |  |  |      +-->|DC|
        |NL+-+  |  | |  |  |          |  | |  |  |          +--+
        +--+ |  |  | |  |  |          |  | |  |  |          |  |
        |  | |  |  | |  |  |          |  | |  |  |          |  |
ddtp--->+--+ +->+--+ +->+--+  ddtp--->+--+ +->+--+  ddtp--->+--+
....

==== Non-leaf DDT entry

A valid (`V==1`) non-leaf DDT entry provides the PPN of the next level DDT.

.Non-leaf device-directory-table entry

[wavedrom, , ]
....
{reg: [
  {bits: 1,  name: 'V',        attr: '1'},
  {bits: 9, name: 'reserved', attr: '9'},
  {bits: 44, name: 'PPN',      attr: '44'},
  {bits: 10,  name: 'reserved', attr: '10'},
], config:{lanes: 2, hspace:1024, fontsize: 16}}
....

==== Leaf DDT entry
The leaf DDT page is indexed by `DDI[0]` and holds the device-context (`DC`).

In base-format the `DC` is 32-bytes. In extended-format the `DC` is 64-bytes.

.Base-format device-context
[wavedrom, , ]
....
{reg: [
  {bits: 64,  name: 'Translation-control (tc)'},
  {bits: 64,  name: 'IO Hypervisor guest address translation and protection (iohgatp)'},
  {bits: 64,  name: 'Translation-attributes (ta)'},
  {bits: 64,  name: 'First-stage-context (fsc)'},
], config:{lanes: 4, hspace: 1024, fontsize: 16}}
....

.Extended-format device-context
[wavedrom, , ]
....
{reg: [
  {bits: 64,  name: 'Translation-control (tc)'},
  {bits: 64,  name: 'IO Hypervisor guest address translation and protection (iohgatp)'},
  {bits: 64,  name: 'Translation-attributes (ta)'},
  {bits: 64,  name: 'First-stage-context (fsc)'},
  {bits: 64,  name: 'MSI-page-table pointer (msiptp)'},
  {bits: 64,  name: 'MSI-address-mask (msi_addr_mask)'},
  {bits: 64,  name: 'MSI-address-pattern (msi_addr_pattern)'},
  {bits: 64,  name: 'reserved'},
], config:{lanes: 8, hspace: 1024, fontsize: 16}}
....

The `DC` is interpreted as four 64-bit doublewords in base-format and as eight
64-bit doublewords in extended-format.  The byte order of each of the
doublewords in memory, little-endian or big-endian, is the endianness as
determined by `fctl.BE` (<<FCTRL>>). The IOMMU may read the `DC` fields in any
order.

==== Device-context fields
===== Translation control (`tc`)

.Translation control (`tc`) field
[wavedrom, , ]
....
{reg: [
  {bits: 1,  name: 'V'},
  {bits: 1,  name: 'EN_ATS'},
  {bits: 1,  name: 'EN_PRI'},
  {bits: 1,  name: 'T2GPA'},
  {bits: 1,  name: 'DTF'},
  {bits: 1,  name: 'PDTV'},
  {bits: 1,  name: 'PRPR'},
  {bits: 1,  name: 'GADE'},
  {bits: 1,  name: 'SADE'},
  {bits: 1,  name: 'DPE'},
  {bits: 1,  name: 'SBE'},
  {bits: 1,  name: 'SXL'},
  {bits: 20, name: 'reserved'},
  {bits: 32, name: 'Designated for custom use'},
], config:{lanes: 4, hspace: 1024, fontsize: 16, fontsize: 16}}
....

`DC` is valid if the `V` bit is 1; If it is 0, all other bits in `DC` are
don't-care and may be freely used by software.

If the IOMMU supports PCIe ATS specification cite:[PCI] (see `capabilities` register),
the `EN_ATS` bit is used to enable ATS transaction processing. If `EN_ATS`
is set to 1, IOMMU supports the following inbound transactions; otherwise
they are treated as unsupported requests.

* Translated read for execute transaction
* Translated read transaction
* Translated write/AMO transaction
* PCIe ATS Translation Request
* PCIe ATS Invalidation Completion Message

If the `EN_ATS` bit is 1 and the `T2GPA` bit is set to 1 the IOMMU performs the
two-stage address translation to determine the permissions and the size of the
translation to be provided in the completion of a PCIe ATS Translation Request
from the device. However, the IOMMU returns a GPA, instead of a SPA, as the
translation of an IOVA in the response. In this mode of operations, the ATC in the
device caches a GPA as a translation for an IOVA and uses the GPA as the address
in subsequent translated memory access transactions. Usually, translated requests
use a SPA and need no further translation to be performed by the IOMMU. However
when `T2GPA` is 1, translated requests from a device use a GPA and are
translated by the IOMMU using the G-stage page table to a SPA. The `T2GPA`
control enables a hypervisor to contain DMA from a device, even if the device
misuses the ATS capability and attempts to access memory that is not associated
with the VM.

[NOTE]
====
When `T2GPA` is enabled, the addresses provided to the device in response to a
PCIe ATS Translation Request cannot be directly routed by the I/O fabric
(e.g. PCI switches) that connect the device to other peer devices and to host.
Such addresses also cannot be routed within the device when peer-to-peer
transactions within the device (e.g. between functions of a device) are
supported.

Hypervisors that configure `T2GPA` to 1 must ensure through protocol-specific
means that translated accesses are routed through the host such that the IOMMU
may translate the GPA and then route the transaction based on PA to memory or
to a peer device. For PCIe, for example, the Access Control Service (ACS) must
be configured to always redirect peer-to-peer (P2P) requests upstream to the
host.

Use of `T2GPA` set to 1 may not be compatible with devices that implement caches
tagged by the translated address returned in response to a PCIe ATS Translation
Request.

As an alternative to setting `T2GPA` to 1, the hypervisor may establish a trust
relationship with the device if authentication protocols are supported by the
device. For PCIe, for example, the PCIe component measurement and authentication
(CMA) capability provides a mechanism to verify the device's configuration and
firmware/executable (Measurement) and hardware identities (Authentication) to
establish such a trust relationship.
====

If `EN_PRI` bit is 0, then PCIe "Page Request" messages from the device are
invalid requests. A "Page Request" message received from a device is responded to
with a "Page Request Group Response" message. Normally, a software handler
generates this response message. However, under some conditions the IOMMU itself
may generate a response. For IOMMU-generated "Page Request Group Response"
messages the PRG-response-PASID-required (`PRPR`) bit when set to 1 indicates
that the IOMMU response message should include a PASID if the associated
"Page Request" had a PASID.

[NOTE]
====
Functions that support PASID and have the "PRG Response PASID Required"
capability bit set to 1, expect that "Page Request Group Response" messages will
contain a PASID if the associated "Page Request" message had a PASID. If the
capability bit is 0, the function does not expect PASID on any "Page Request
Group Response" message and the behavior of the function if it receives the
response with a PASID is undefined. The `PRPR` bit should be configured
with the value held in the "PRG Response PASID Required" capability bit.
====

Setting the disable-translation-fault (`DTF`) bit to 1 disables reporting of
faults encountered in the address translation process. Setting `DTF` to 1 does
not disable error responses from being generated to the device in response to
faulting transactions. Setting `DTF` to 1 does not disable reporting of faults
from the IOMMU that are not related to the address translation process. The
faults that are not reported when `DTF` is 1 are listed in <<FAULT_CAUSE>>.

[NOTE]
====
A hypervisor may set `DTF` to 1 to disable fault reporting when it has
identified conditions that may lead to a flurry of errors such as due to an
abnormal termination of a virtual machine.
====

The `fsc` field of `DC` holds the context for first-stage translations (S-stage
or VS-stage). If the `PDTV` bit is 1, the field holds the PPN of the root page
of PDT.  If the `PDTV` bit is 0 and `iohgatp.MODE` is `Bare`, the `fsc` field
holds the PPN of the root page of a S-stage page table (i.e. `iosatp`).
if the `PDTV` bit is 0 and `iohgatp.MODE` is not `Bare`, the `fsc` field holds
the PPN of the root page of a VS-stage page table (i.e. `iovsatp`).

The `PDTV` bit is expected to be set to 1 when `DC` is associated with a device
that supports multiple process contexts and thus generates a valid `process_id`
with its memory accesses. For PCIe, for example, if the request has a PASID
then the PASID is used as the `process_id`.

When `PDTV` is 1, the `DPE` bit may set to 1 to enable the use of 0 as the default
value of `process_id` for translating requests without a valid `process_id`. When
`PDTV` is 0, the `DPE` bit is reserved for future standard extension.

The IOMMU supports the 1 setting of `GADE` and `SADE` bits if `capabilities.AMO`
is 1. When `capabilities.AMO` is 0, these bits are reserved.

If `GADE` is 1, the IOMMU updates A and D bits in G-stage PTEs atomically. If
`GADE` is 0, the IOMMU causes a guest-page-fault corresponding to the original
access type if the A bit is 0 or if the memory access is a store and the D bit is 0.

If `SADE` is 1, the IOMMU updates A and D bits in S/VS-stage PTEs atomically. If
`SADE` is 0, the IOMMU causes a page-fault corresponding to the original access
type if the A bit is 0 or if the memory access is a store and the D bit is 0.

If `SBE` is 0, implicit memory accesses to PDT entries and S/VS-stage PTEs are
little-endian else they are big-endian. The supported values of `SBE` are the
same as that of the `fctl.BE` field.


The `SXL` field controls the supported paged virtual-memory schemes as defined
in <<IOSATP_MODE_ENC>>. If `fctl.GXL` is 1 then the `SXL` field must be 1; otherwise
the legal values for the `SXL` field are the same as that of the `fctl.GXL`.

When `SXL` is 1, the following rules apply:

* If the S/VS-stage page table is not `Bare` then a page fault corresponding to
  the original access type occurs if the `IOVA` has bits set beyond bit 31.
* If the G-stage page table is not `Bare`, then a guest page fault corresponding
  to the original access type occurs if the incoming GPA has bits set beyond bit
  33.

===== IO hypervisor guest address translation and protection (`iohgatp`)
The `iohgatp` field holds the PPN of the root G-stage page table and a
virtual machine identified by a guest soft-context ID (`GSCID`), to facilitate
address-translation fences on a per-virtual-machine basis. If multiple devices
are associated to a VM with a common G-stage page table, the hypervisor is
expected to program the same `GSCID` in each `iohgatp`. The `MODE` field is used
to select the G-stage address translation scheme.

The G-stage page table formats are as defined by the Privileged specification.
The `fctl.GXL` field controls the supported address-translation schemes for
guest physical addresses as defined in <<IOHGATP_MODE_ENC>>.

The `iohgatp` `MODE` field identifies the paged virtual-memory schemes and its
encodings are as follows:

[[IOHGATP_MODE_ENC]]
.Encodings of `iohgatp.MODE` field
[width=75%]
[%header, cols="3,3,20"]
|===
3+^|               `fctl.GXL=0`
|Value | Name     | Description
| 0    | `Bare`   | No translation or protection.
| 1-7  | --       | Reserved for standard use.
| 8    | `Sv39x4` | Page-based 41-bit virtual addressing (2-bit extension
                    of Sv39).
| 9    | `Sv48x4` | Page-based 50-bit virtual addressing (2-bit extension
                    of Sv48).
| 10   | `Sv57x4` | Page-based 59-bit virtual addressing (2-bit extension
                    of Sv57).
| 11-15| --       | Reserved for standard use.
3+^|               `fctl.GXL=1`
|Value | Name     | Description
| 0    | `Bare`   | No translation or protection.
| 1-7  | --       | Reserved for standard use.
| 8    | `Sv32x4` | Page-based 34-bit virtual addressing (2-bit extension
                    of Sv32).
| 9-15 | --       | Reserved for standard use.
|===

Implementations are not required to support all defined mode settings for
`iohgatp`. The IOMMU only needs to support the modes also supported by the MMU
in the harts integrated into the system or a subset thereof.

The root page table as determined by `iohgatp.PPN` is 16 KiB and must be aligned
to a 16-KiB boundary.

[NOTE]
====
The `GSCID` field of `iohgatp` identifies an address space. Configuring
identical `GSCID` in two `DC` when the G-stage page-table referenced by the two
`DC` are not identical then it is unpredictable whether the IOMMU uses the
PTEs from the first page table or the second page table. These are the only
expected behaviors.
====

.IO hypervisor guest address translation and protection (`iohgatp`) field
[wavedrom, , ]
....
{reg: [
  {bits: 44, name: 'PPN'},
  {bits: 16, name: 'GSCID'},
  {bits: 4,  name: 'MODE'},
], config:{lanes: 2, hspace: 1024, fontsize: 16}}
....

===== Translation attributes (`ta`)

.Translation attributes (`ta`) field
[wavedrom, , ]
....
{reg: [
  {bits: 12, name: 'reserved'},
  {bits: 20, name: 'PSCID'},
  {bits: 32, name: 'reserved'},
], config:{lanes: 2, hspace: 1024, fontsize: 16}}
....

The `PSCID` field of `ta` provides the process soft-context ID that identifies
the address-space of the process. `PSCID` facilitates address-translation
fences on a per-address-space basis. The `PSCID` field in `ta` is used as the
address-space ID if `PDTV` is 0 and the `iosatp`/`iovsatp` `MODE` field is not
`Bare`. When `PDTV` is 1, the `PSCID` field in `ta` is ignored.

===== First-Stage context (`fsc`)
If `PDTV` is 0, the `fsc` field in `DC` holds the `iosatp` (when `iohgatp MODE`
is `Bare`) or the `iovsatp` (when `iohgatp MODE` is not `Bare`) that provide the
controls for S-stage page table or VS-stage address translation and protection
respectively.

.IO (Virtual)Supervisor addr. translation and prot. (`iovsatp`/`iosatp`) field (when `PDTV` is 0)
[wavedrom, , ]
....
{reg: [
  {bits: 44, name: 'PPN'},
  {bits: 16, name: 'reserved'},
  {bits: 4,  name: 'MODE'},
], config:{lanes: 2, hspace: 1024, fontsize: 16}}
....

The S/VS-stage page table formats are as defined by the Privileged
specification.

The `DC.tc.SXL` field controls the supported paged virtual-memory schemes.

The `iosatp`/`iovsatp` `MODE` identifies the paged virtual-memory schemes and
is encoded as follows:

[[IOSATP_MODE_ENC]]
.Encodings of `iosatp/iovsatp.MODE` field
[width=75%]
[%header, cols="3,3,20"]
|===
3+^|               `DC.tc.SXL=0`
|Value | Name     | Description
| 0    | `Bare`   | No translation or protection.
| 1-7  | --       | Reserved for standard use.
| 8    | `Sv39`   | Page-based 39-bit virtual addressing.
| 9    | `Sv48`   | Page-based 48-bit virtual addressing.
| 10   | `Sv57`   | Page-based 57-bit virtual addressing.
| 11-13| --       | Reserved for standard use.
| 14-15| --       | Designated for custom use.
3+^|               `DC.tc.SXL=1`
|Value | Name     | Description
| 0    | `Bare`   | No translation or protection.
| 1-7  | --       | Reserved for standard use.
| 8    | `Sv32`   | Page-based 32-bit virtual addressing.
| 9-15 | --       | Reserved for standard use.
|===

When `PDTV` is 1, the `fsc` field holds the process-directory table pointer
(`pdtp`). When the device supports multiple process contexts, selected by the
`process_id`, the PDT is used to determine the S/VS-stage page table and
associated `PSCID` for virtual address translation and protection.

The `pdtp` field holds the PPN of the root PDT and the `MODE` field that
determines the number of levels of the PDT.

.Process-directory table pointer (`pdtp`) field (when `PDTV` is 1)
[wavedrom, , ]
....
{reg: [
  {bits: 44, name: 'PPN'},
  {bits: 16, name: 'reserved'},
  {bits: 4,  name: 'MODE'},
], config:{lanes: 2, hspace: 1024, fontsize: 16}}
....

When two-stage address translation is active (`iohgatp.MODE != Bare`), the `PPN`
field holds a guest PPN.  The GPA of the root PDT is then converted by guest
physical address translation, as controlled by the `iohgatp`, into a supervisor
physical address. Translating addresses of root PDT root through G-stage page
tables, allows the PDT to be held in memory allocated by the guest OS and allows
the guest OS to directly edit the PDT to associate a virtual-address space
identified by a VS-stage page table with a `process_id`.

[[PDTP_MODE_ENC]]
.Encoding of `pdtp.MODE` field
[width=75%]
[%header, cols="3,3,20"]
|===
|Value | Name     | Description
| 0    | `Bare`   | No translation or protection. First stage translation is
                    not enabled.
| 1    | `PD8`    | 8-bit process ID enabled. The directory has 1 levels with
                    256 entries.The bits 19:8 of `process_id` must be 0.
| 2    | `PD17`   | 17-bit process ID enabled. The directory has 2 levels.
                    The root PDT page has 512 entries and leaf level has
                    256 entries. The bits 19:17 of `process_id` must be 0.
| 3    | `PD20`   | 20-bit process ID enabled. The directory has 3 levels.
                    The root PDT has 8 entries and the next non-leaf
                    level has 512 entries. The leaf level has 256 entries.
|  4-13| --       | Reserved for standard use.
| 14-15| --       | Designated for custom use.
|===

===== MSI page table pointer (`msiptp`)

The `msiptp` field holds the PPN of the root MSI page table used to direct an
MSI to a guest interrupt file in an IMSIC. The MSI page table formats are
defined by the Advanced Interrupt Architecture specification.

The `MODE` field is used to select the MSI address translation scheme.

.MSI page table pointer (`msiptp`) field
[wavedrom, , ]
....
{reg: [
  {bits: 44, name: 'PPN'},
  {bits: 16, name: 'reserved'},
  {bits: 4,  name: 'MODE'},
], config:{lanes: 2, hspace: 1024, fontsize: 16}}
....

.Encoding of `msiptp` `MODE` field
[width=75%]
[%header, cols="3,3,20"]
|===
|Value | Name     | Description
| 0    | `Bare`   | No translation or protection. Recognition of accesses to
                    a virtual interrupt file using MSI address mask and
                    pattern is not performed.
| 1    | `Flat`   | Flat MSI page table
|  2-13| --       | Reserved for standard use.
| 14-15| --       | Designated for custom use.
|===

[[MSI_ID]]
===== MSI address mask (`msi_addr_mask`) and pattern (`msi_addr_pattern`)

The MSI address mask (`msi_addr_mask`) and pattern (`msi_addr_pattern`) fields
are used to identify the 4-KiB pages of virtual interrupt files in the guest
physical address space of the relevant VM. An incoming memory access made by a
device is recognized as an access to a virtual interrupt file if the destination
guest physical page matches the supplied address pattern in all bit positions
that are zeros in the supplied address mask. In detail, a memory access to guest
physical address `A` is recognized as an access to a virtual interrupt file's
memory-mapped page if:

`(A >> 12) & ~msi_addr_mask = (msi_addr_pattern & ~msi_addr_mask)`

where >> 12 represents shifting right by 12 bits, an ampersand (&) represents
bitwise logical AND, and `~msi_addr_mask` is the bitwise logical complement of
the address mask.

.MSI address mask (`msi_addr_mask`) field
[wavedrom, , ]
....
{reg: [
  {bits: 52, name: 'mask'},
  {bits: 12, name: 'reserved'},
], config:{lanes: 2, hspace: 1024, fontsize: 16}}
....
.MSI address pattern (`msi_addr_pattern`) field
[wavedrom, , ]
....
{reg: [
  {bits: 52, name: 'pattern'},
  {bits: 12, name: 'reserved'},
], config:{lanes: 2, hspace: 1024, fontsize: 16}}
....

[[DC_MISCONFIG]]
==== Device-context configuration checks

A `DC` with `V=1` is considered as misconfigured if any of the following
conditions are true. If misconfigured then, stop and report "DDT entry
misconfigured" (cause = 259).

. If any bits or encoding that are reserved for future standard use are set
. `capabilities.ATS` is 0 and `DC.tc.EN_ATS`, or `DC.tc.EN_PRI`,
   or `DC.tc.PRPR` is 1
. `DC.tc.EN_ATS` is 0 and `DC.tc.T2GPA` is 1
. `DC.tc.EN_ATS` is 0 and `DC.tc.EN_PRI` is 1
. `DC.tc.EN_PRI` is 0 and `DC.tc.PRPR` is 1
. `capabilities.T2GPA` is 0 and `DC.tc.T2GPA` is 1
. `DC.tc.T2GPA` is 1 and `DC.iohgatp.MODE` is `Bare`
. `DC.tc.PDTV` is 1 and `DC.fsc.pdtp.MODE` is not a supported mode
.. `capabilities.PD20` is 0 and `DC.fsc.pdtp.MODE` is `PD20`
.. `capabilities.PD17` is 0 and `DC.fsc.pdtp.MODE` is `PD17`
.. `capabilities.PD8` is 0 and `DC.fsc.pdtp.MODE` is `PD8`
. `DC.tc.PDTV` is 0 and `DC.fsc.iosatp.MODE` encoding is not a valid
   encoding as determined by <<IOSATP_MODE_ENC>>
. `DC.tc.PDTV` is 0 and `DC.tc.SXL` is 0 `DC.fsc.iosatp.MODE`
  is not one of the supported modes
.. `capabilities.Sv39` is 0 and `DC.fsc.iosatp.MODE` is `Sv39`
.. `capabilities.Sv48` is 0 and `DC.fsc.iosatp.MODE` is `Sv48`
.. `capabilities.Sv57` is 0 and `DC.fsc.iosatp.MODE` is `Sv57`
. `DC.tc.PDTV` is 0 and `DC.tc.SXL` is 1 `DC.fsc.iosatp.MODE`
  is not one of the supported modes
.. `capabilities.Sv32` is 0 and `DC.fsc.iosatp.MODE` is `Sv32`
. `DC.tc.PDTV` is 0 and `DC.tc.DPE` is 1
. `DC.iohgatp.MODE` encoding is not a valid encoding as determined
  by <<IOHGATP_MODE_ENC>>
. `fctl.GXL` is 0 and `DC.iohgatp.MODE` is not a supported mode
.. `capabilities.Sv39x4` is 0 and `DC.iohgatp.MODE` is `Sv39x4`
.. `capabilities.Sv48x4` is 0 and `DC.iohgatp.MODE` is `Sv48x4`
.. `capabilities.Sv57x4` is 0 and `DC.iohgatp.MODE` is `Sv57x4`
. `fctl.GXL` is 1 and `DC.iohgatp.MODE` is not a supported mode
.. `capabilities.Sv32x4` is 0 and `DC.iohgatp.MODE` is `Sv32x4`
. `capabilities.MSI_FLAT` is 1 and `DC.msiptp.MODE` is not `Bare`
   and not `Flat`
. `DC.iohgatp.MODE` is not `Bare` and the root page table determined by
  `DC.iohgatp.PPN` is not aligned to a 16-KiB boundary.
. `capabilities.AMO` is 0 and `DC.tc.SADE` or `DC.tc.GADE` is 1
. `capabilities.END` is 0 and `fctl.BE != DC.tc.SBE`
. `DC.tc.SXL` value is not a legal value. If `fctl.GXL` is 1, then
  `DC.tc.SXL` must be 1. If `fctl.GXL` is 0 and is writable, then
  `DC.tc.SXL` may be 0 or 1. If `fctl.GXL` is 0 and is not writable
  then `DC.tc.SXL` must be 0.
. `DC.tc.SBE` value is not a legal value. If `fctl.BE` is writable
  then `DC.tc.SBE` may be 0 or 1. If `fctl.BE` is not writable then
  `DC.tc.SBE` must be the same as `fctl.BE`.

[NOTE]
====
Some `DC` fields hold supervisor physical addresses or
guest physical addresses. Some implementations may verify the validity of the
addresses - e.g. the supervisor physical address is not wider than that supported as
determined by `capabilities.PAS`, etc. at the time of locating the `DC`. Such
implementations may cause a "DDT entry misconfigured" (cause = 259) fault.

Other implementations only detect such addresses to be invalid when the data
structure referenced by these fields needs to be accessed. Such
implementations may detect access-violation faults in the process of making the
access.
====

=== Process-Directory-Table (PDT)

The PDT is a 1, 2, or 3-level radix tree indexed using the process directory
index (`PDI`) bits of the `process_id`.

The following diagrams illustrate the PDT radix-tree. The root
process-directory page number is located using the process-directory-table
pointer (`pdtp`) field of the device-context. Each non-leaf (`NL`) entry
provides the PPN of the next level process-directory-table. The leaf
process-directory-table entry holds the process-context (`PC`).

.Three, two and single-level process directory
["ditaa",shadows=false, separation=false, font=courier, fontsize: 16]
....
  +-------+-------+-------+      +-------+-------+   +-------+
  |PDI[2] |PDI[1] |PDI[0] |      |PDI[1] |PDI[0] |   |PDI[0] |
  +--+----+--+----+--+----+      +-+-----+-+-----+   +-+-----+
     |       |       |             |       |           |
     +-3−bit +-9−bit +-8−bit       +-9−bit +-8−bit     +-8−bit
     |       |       |             |       |           |
     |  +--+ |  +--+ |  +--+       |  +--+ |  +--+     |   +--+
     |  |  | |  |  | |  |  |       |  |  | |  |  |     |   |  |
     |  |  | |  |  | |  +--+       |  |  | |  +--+     |   |  |
     |  |  | |  |  | +->|PC|       |  |  | +->|PC|     |   |  |
     |  |  | |  +--+    +--+       |  |  |    +--+     |   |  |
     |  |  | +->|NL+-+  |  |       |  +--+    |  |     |   |  |
     |  |  |    +--+ |  |  |       +->|NL+-+  |  |     |   +--+
     +->+--+    |  | |  |  |          +--+ |  |  |     +-->|PC|
        |NL+-+  |  | |  |  |          |  | |  |  |         +--+
        +--+ |  |  | |  |  |          |  | |  |  |         |  |
        |  | |  |  | |  |  |          |  | |  |  |         |  |
pdtp--->+--+ +->+--+ +->+--+  pdtp--->+--+ +->+--+ pdtp--->+--+
....

==== Non-leaf PDT entry

A valid (`V==1`) non-leaf PDT entry holds the PPN of the next-level PDT.

.Non-leaf process-directory-table entry

[wavedrom, , ]
....
{reg: [
  {bits:  1, name: 'V',        attr: '1'},
  {bits:  9, name: 'reserved', attr: '9'},
  {bits: 44, name: 'PPN',      attr: '44'},
  {bits: 10, name: 'reserved', attr: '10'},
], config:{lanes: 2, hspace:1024, fontsize: 16}}
....

==== Leaf PDT entry
The leaf PDT page is indexed by `PDI[0]` and holds the 16-byte process-context
(`PC`).

.Process-context

[wavedrom, , ]
....
{reg: [
  {bits: 64,  name: 'Translation-attributes (ta)'},
  {bits: 64,  name: 'First-stage-context (fsc)'},
], config:{lanes: 2, hspace: 1024, fontsize: 16}}
....

The `PC` is interpreted as two 64-bit doublewords. The byte order of each of the
doublewords in memory, little-endian or big-endian, is the endianness as
determined by `DC.tc.SBE`. The IOMMU may read the `PC` fields in any order.

==== Process-context fields

===== Translation attributes (`ta`)

.Translation attributes (`ta`) field
[wavedrom, , ]
....
{reg: [
  {bits: 1,  name: 'V',        attr: '1'},
  {bits: 1,  name: 'ENS',     attr: '1'},
  {bits: 1,  name: 'SUM',    attr: '1'},
  {bits: 9, name: 'reserved', attr: '9'},
  {bits: 20, name: 'PSCID',    attr: '20'},
  {bits: 32, name: 'reserved', attr: '32'},
], config:{lanes: 4, hspace: 1024, fontsize: 16}}
....

`PC` is valid if the `V` bit is 1; If it is 0, all other bits in `PC` are don't
care and may be freely used by software.

When Enable-Supervisory-access (`ENS`) is 1, transactions requesting supervisor
privilege are allowed with this `process_id` else the transaction is treated as
an unsupported request.

When `ENS` is 1, the `SUM` (permit Supervisor User Memory access) bit
modifies the privilege with which supervisor privilege transactions access
virtual memory. When `SUM` is 0, supervisor privilege transactions to pages
mapped with `U`-bit in PTE set to 1 will fault.

When `ENS` is 1, supervisor privilege transactions that read with execute
intent to pages mapped with `U` bit in PTE set to 1 will fault, regardless of
the state of `SUM`.

===== First-Stage context (`fsc`)
If `PDTV` is 0, the `fsc` field in `DC` holds the `iosatp` (when `iohgatp MODE`
is `Bare`) or the `iovsatp` (when `iohgatp MODE` is not `Bare`) that provide
the controls for S-stage page or VS-stage address translation and protection
respectively.

.IO (Virtual)Supervisor addr. translation and prot. (`iovsatp`/`iosatp`) field (when `PDTV` is 1)
[wavedrom, , ]
....
{reg: [
  {bits: 44, name: 'PPN'},
  {bits: 16, name: 'reserved'},
  {bits: 4,  name: 'MODE'},
], config:{lanes: 2, hspace: 1024, fontsize: 16}}
....

A valid (`V==1`) leaf PDT entry holds the PPN of the root page of a S/VS-stage
page table and the `MODE` used to determine the S/VS-stage address translation
scheme. The `MODE` field encoding are as defined for the `MODE` field in the
`satp`/`vsatp` CSR.

The software assigned process soft-context ID (`PSCID`) is used as the address
space ID for the process identified by the S/VS-stage page table.

When two-stage address translation is active (`iohgatp.MODE != Bare`), the `PPN`
field holds a guest PPN of the root of a VS-stage page table. Addresses of the
VS-stage page table entries are then converted by guest physical address
translation process, as controlled by the `iohgatp`, into a supervisor physical
address. A guest OS may thus directly edit the VS-stage page table to limit
access by the device to a subset of its memory and specify permissions for the
device accesses.

[NOTE]
====
The `PSCID` field of `PC` identified an address space. Configuring identical
`PSCID` in two `PC` when the page-table referenced by the two `PC` are not
identical then it is unpredictable whether the IOMMU uses the PTEs from the
first page table or the second page table. These are the only expected
behaviors.
====

[[PC_MISCONFIG]]
==== Process-context configuration checks

A `PC` with `V=1` is considered as misconfigured if any of the following
conditions are true. If misconfigured then stop and report "PDT entry
misconfigured" (cause = 267).

. If any bits or encoding that are reserved for future standard use are set
. `PC.fsc.MODE` encoding is not valid as determined by <<IOSATP_MODE_ENC>>
. `DC.tc.SXL` is 0 and `PC.fsc.MODE` is not one of the supported modes
.. `capabilities.Sv39` is 0 and `PC.fsc.MODE` is `Sv39`
.. `capabilities.Sv48` is 0 and `PC.fsc.MODE` is `Sv48`
.. `capabilities.Sv57` is 0 and `PC.fsc.MODE` is `Sv57`
. `DC.tc.SXL` is 1 and `PC.fsc.MODE` is not one of the supported modes
.. `capabilities.Sv32` is 0 and `PC.fsc.MODE` is `Sv32`

[NOTE]
====
Some `PC` fields hold supervisor physical addresses or
guest physical addresses. Some implementations may verify the validity of the
addresses - e.g. the supervisor physical address is not wider than that supported
as determined by `capabilities.PAS`, etc. at the time of locating the `PC`.
Such implementations may cause a "PDT entry misconfigured" (cause = 267) fault.

Other implementations only detect such addresses to be invalid when the data
structure referenced by these fields needs to be accessed. Such implementations
may detect access-violation faults in the process of making the access.
====

[[P2IOVA]]
=== Process to translate an IOVA

The process to translate an IOVA uses the hardware IDs (`device_id` and
`process_id`) to locate the Device-Context and the Process-Context. The
Device-context and Process-context provide the root PPN of the page tables,
`PSCID`, `GSCID`, and other control parameters that affect the address
translation and protection process. When address translation caches
(<<CACHING>>) are implemented, the translation process may use the `GSCID` and
`PSCID` to associate the cached translations with their address spaces.

The process to translate an `IOVA` is as follows:

. If `ddtp.iommu_mode == Off` then stop and report "All inbound transactions
  disallowed" (cause = 256).
. If `ddtp.iommu_mode == Bare` and any of the following conditions hold then
  stop and report "Transaction type disallowed" (cause = 260); else go to step
  21 with translated address same as the `IOVA`.
..  Transaction type is a Translated request (read, write/AMO, read-for-execute)
    or is a PCIe ATS Translation request.
. If `capabilities.MSI_FLAT` is 0 then the IOMMU uses base-format device
  context. Let `DDI[0]` be `device_id[6:0]`, `DDI[1]` be `device_id[15:7]`, and
  `DDI[2]` be `device_id[23:16]`.
. If `capabilities.MSI_FLAT` is 1 then the IOMMU uses extended-format device
  context. Let `DDI[0]` be `device_id[5:0]`, `DDI[1]` be `device_id[14:6]`, and
  `DDI[2]` be `device_id[23:15]`.
. The `device_id` is wider than that supported by the IOMMU mode if any of the
  following conditions hold. If the following conditions hold then stop and
  report "Transaction type disallowed" (cause = 260).
.. `ddtp.iommu_mode` is `2LVL` and `DDI[2]` is not 0
.. `ddtp.iommu_mode` is `1LVL` and either `DDI[2]` is not 0 or `DDI[1]` is not 0
. Use `device_id` to then locate the device-context (`DC`) as specified in
  <<GET_DC>>.
. If any of the following conditions hold then stop and report
  "Transaction type disallowed" (cause = 260).
..  Transaction type is a Translated request (read, write/AMO, read-for-execute)
    or is a PCIe ATS Translation request and `DC.tc.EN_ATS` is 0.
..  Transaction has a valid `process_id` and `DC.tc.PDTV` is 0.
..  Transaction has a valid `process_id` and `DC.tc.PDTV` is 1 and the
    `process_id` is wider than supported by `pdtp.MODE`.
..  Transaction type is not supported by the IOMMU.
. If request is a Translated request and `DC.tc.T2GPA` is 0 then the translation
  process is complete. Go to step 21.
. If request is a Translated request and `DC.tc.T2GPA` is 1 then the IOVA is a
  GPA. Go to step 17 with following page table information:
.. Let `A` be the `IOVA` (the `IOVA` is a GPA).
.. Let `iosatp.MODE` be `Bare`
... The `PSCID` value is not used when first-stage mode is `Bare`.
.. Let `iohgatp` be the value in the `DC.iohgatp` field
. If `DC.tc.PDTV` is set to 0 then go to step 17 with the following page table
  information:
.. Let `iosatp.MODE` be the value in the `DC.fsc.MODE` field
.. Let `iosatp.PPN` be the value in the `DC.fsc.PPN` field
.. Let `PSCID` be the value in the `DC.ta.PSCID` field
.. Let `iohgatp` be the value in the `DC.iohgatp` field
.. If a G-stage page table is not active in the device-context
     (`DC.iohgatp.mode` is `Bare`) then `iosatp` is a a S-stage page-table else
     it is a VS-stage page table.
. If `DPE` is 1 and there is no `process_id` associated with the transaction
  then let `process_id` be the default value of 0.
. If `DPE` is 0 and there is no `process_id` associated with the transaction
  then then go to step 17 with the following page table information:
.. Let `iosatp.MODE` be `Bare`
... The `PSCID` value is not used when first-stage mode is `Bare`.
.. Let `iohgatp` be the value in the `DC.iohgatp` field
. If `DC.fsc.pdtp.MODE = Bare` then go to step 17 with the following page table
  information:
.. Let `iosatp.MODE` be `Bare`
... The `PSCID` value is not used when first-stage mode is `Bare`.
.. Let `iohgatp` be value in `DC.iohgatp` field
. Locate the process-context (`PC`) as specified in <<GET_PC>>.
. if any of the following conditions hold then stop and report
  "Transaction type disallowed" (cause = 260).
..  The transaction requests supervisor privilege but `PC.ta.ENS` is not set.
. Go to step 17 with the following page table information:
.. Let `iosatp.MODE` be the value in the `PC.fsc.MODE` field
.. Let `iosatp.PPN` be the value in the `PC.fsc.PPN` field
.. Let `PSCID` be the value in the `PC.ta.PSCID` field
.. Let `iohgatp` be the value in the `DC.iohgatp` field
.. If a G-stage page table is not active in the device-context
   (`DC.iohgatp.mode` is `Bare`) then `iosatp` is a S-stage page-table else
   it is a VS-stage page table.
. If a G-stage page table is not active in the device-context then use the
  single-stage address translation process specified in Section "Virtual Address
  Translation Process" of the RISC-V privileged specification cite:[PRIV]. If a
  fault is detected by the single stage address translation process then stop and
  report the fault else go to step 21.
. If a G-stage page table is active in the device-context then use the
  process specified in Section "Two-Stage Address Translation" of the RISC-V
  Privileged specification cite:[PRIV] to perform the VS-stage address translation to
  determine the GPA accessed by the transaction. If a fault is detected by the
  two stage address translation process then stop and report the fault. If the
  translation process is completed then let `A` be the translated GPA.
. If MSI address translations using MSI page tables is enabled
  (`DC.msiptp.MODE != Bare`) then the MSI address translation process specified
  in <<MSI_TRANS>> is invoked. If the GPA `A` is not determined to be the
  address of a virtual interrupt file then the process continues at step 20. If
  a fault is detected by the MSI address translation process then stop and
  report the fault else the process continues at step 21.
. If a G-stage page table is active in the device-context then use the
  G-stage address translation process specified in Section "Two-Stage Address
  Translation" of the RISC-V Privileged specification cite:[PRIV] to translate the
  GPA `A` to determine the SPA accessed by the transaction. If a fault is detected
  by the address translation process then stop and report the fault.
. Translation process is complete

When checking the `U` bit in a G-stage PTE, the transaction is treated as not
requesting supervisor privilege.

When the translation process reports a fault, and the request is an Untranslated
request or a Translated request, the IOMMU requests the IO bridge to abort the
transaction. Guidelines for handling faulting transactions in the IO bridge are
provided in <<IOBR_FAULT_RESP>>. The fault may be reported using the fault/event
reporting mechanism and fault record formats specified in <<FAULT_QUEUE>>.

If the fault was detected by a PCIe ATS Translation Request then the IOMMU may
provide a PCIe protocol defined response instead of reporting fault to software
or causing an abort. The handling of faulting PCIe ATS Translation Requests is
specified in <<ATS_FAULTS>>.

[[GET_DC]]
==== Process to locate the Device-context

The process to locate the Device-context for transaction using its `device_id`
is as follows:

. Let `a` be `ddtp.PPN x 2^12^` and let `i = LEVELS - 1`. When
  `ddtp.iommu_mode` is `3LVL`, `LEVELS` is three. When `ddtp.iommu_mode` is
  `2LVL`, `LEVELS` is two. When `ddtp.iommu_mode` is `1LVL`, `LEVELS` is one.
. If `i == 0` go to step 8.
. Let `ddte` be the value of the eight bytes at address `a + DDI[i] x 8`. If accessing
  `ddte` violates a PMA or PMP check, then stop and report "DDT entry load
  access fault" (cause = 257).
. If `ddte` access detects a data corruption (a.k.a. poisoned data), then
  stop and report "DDT data corruption" (cause = 268).
. If `ddte.V == 0`, stop and report "DDT entry not valid" (cause = 258).
. If if any bits or encoding that are reserved for future standard use are
  set within `ddte`, stop and report "DDT entry misconfigured"
  (cause = 259).
. Let `i = i - 1` and let `a = ddte.PPN x 2^12^`. Go to step 2.
. Let `DC` be the value of `DC_SIZE` bytes at address `a + DDI[0] * DC_SIZE`. If
  `capabilities.MSI_FLAT` is 1 then `DC_SIZE` is 64-bytes else it is 32-bytes.
  If accessing `DC` violates a PMA or PMP check, then stop and report
  "DDT entry load access fault" (cause = 257). If `DC` access detects a data
  corruption (a.k.a. poisoned data), then stop and report "DDT data corruption"
  (cause = 268).
. If `DC.tc.V == 0`, stop and report "DDT entry not valid" (cause = 258).
. If the `DC` is misconfigured as determined by rules outlined in
  <<DC_MISCONFIG>> then stop and report "DDT entry misconfigured" (cause = 259).
. The device-context has been successfully located and may be cached.

[[GET_PC]]
==== Process to locate the Process-context

The device-context provides the PDT root page PPN (`pdtp.ppn`).  When
`DC.iohgatp.mode` is not `Bare`, `pdtp.PPN` as well as `pdte.PPN` are Guest
Physical Addresses (GPA) which must be translated into Supervisor Physical
Addresses (SPA) using the G-stage page table pointed to by `DC.iohgatp`.
The memory accesses to the PDT are treated as implicit read memory accesses
by the G-stage page table.

The process to locate the Process-context for a transaction using its
`process_id` is as follows:

. Let `a` be `pdtp.PPN x 2^12^` and let `i = LEVELS - 1`. When
  `pdtp.MODE` is `PD20`, `LEVELS` is three. When `pdtp.MODE` is
  `PD17`, `LEVELS` is two. When `pdtp.MODE` is `PD8`, `LEVELS` is one.
. If `DC.iohgatp.mode != Bare`, then `a` is a GPA. Invoke the process
  to translate `a` to a SPA as an implicit memory access. If faults occur during
  G-stage address translation of `a` then stop and report the fault detected by the
  G-stage address translation process. The translated `a` is used in subsequent
  steps.
. If `i == 0` go to step 9.
. Let `pdte` be the value of the eight bytes at address `a + PDI[i] x 8`. If
  accessing `pdte` violates a PMA or PMP check, then stop and report
  "PDT entry load access fault" (cause = 265).
. If `pdte` access detects a data corruption (a.k.a. poisoned data), then
  stop and report "PDT data corruption" (cause = 269).
. If `pdte.V == 0`, stop and report "PDT entry not valid" (cause = 266).
. If any bits or encoding that are reserved for future standard use are
  set within `pdte`, stop and report "PDT entry misconfigured" (cause = 267).
. Let `i = i - 1` and let `a = pdte.PPN x 2^12^`. Go to step 2.
. Let `PC` be the value of the 16-bytes at address `a + PDI[0] x 16`. If accessing `PC`
  violates a PMA or PMP check, then stop and report "PDT entry load access
  fault" (cause = 265). If `PC` access detects a data corruption
  (a.k.a. poisoned data), then stop and report "PDT data corruption"
  (cause = 269).
. If `PC.ta.V == 0`, stop and report "PDT entry not valid" (cause = 266).
. If the `PC` is misconfigured as determined by rules outlined in
  <<PC_MISCONFIG>> then stop and report "PDT entry misconfigured" (cause = 267).
. The Process-context has been successfully located.

[[MSI_TRANS]]
==== Process to translate addresses of MSIs

When an I/O device is configured directly by a guest operating system, MSIs
from the device are expected to be targeted to virtual IMSICs within the guest
OS's virtual machine, using guest physical addresses that are inappropriate
and unsafe for the real machine. An IOMMU must recognize certain incoming
writes from such devices as MSIs and convert them as needed for the real
machine.

MSIs originating from a single device that require conversion are expected
to have been configured at the device by a single guest OS running within one
RISC-V virtual machine. Assuming the VM itself conforms to the RISC-V Advanced
Interrupt Architecture cite:[AIA], MSIs are sent to virtual harts within the VM by writing
to the memory-mapped registers of the interrupt files of virtual IMSICs. Each of
these virtual interrupt files occupies a separate 4-KiB page in the VM's guest
physical address space, the same as real interrupt files do in a real machine's
physical address space. A write to a guest physical address can thus be
recognized as an MSI to a virtual hart if the write is to a page occupied by
an interrupt file of a virtual IMSIC within the VM.

When MSI address translation is supported (`capabilities.MSI_FLAT`, <<CAP>>),
the process to identify an incoming `IOVA` as the address of a virtual interrupt
file and translating the address using the MSI page table is as follows:

. Let `A` be the `GPA`
. Let `DC` be the device-context located using the `device_id` of the device
  using the process outlined in <<GET_DC>>.
. Determine if the address `A` is an access to a virtual interrupt file as
  specified in <<MSI_ID>>.
. If the address is not determined to be that of a virtual interrupt file then
  stop this process and instead use the regular translation data structures to
  do the address translation.
. Extract an interrupt file number `I` from `A` as
  `I = extract(A >> 12, DC.msi_addr_mask)`. The bit extract function
  `extract(x, y)` discards all bits from `x` whose matching bits in the same
  positions in the mask `y` are zeros, and packs the remaining bits from `x`
  contiguously at the least-significant end of the result, keeping the same bit
  order as `x` and filling any other bits at the most-significant end of the
  result with zeros. For example, if the bits of `x` and `y` are:
** `x = a b c d e f g h`
** `y = 1 0 1 0 0 1 1 0`
** then the value of `extract(x, y)` has bits `0 0 0 0 a c f g`.

. Let `m` be `(DC.msiptp.PPN x 2^12^)`.
. Let `msipte` be the value of sixteen bytes at address `(m | (I x 16))`. If
  accessing `msipte` violates a PMA or PMP check, then stop and report
  "MSI PTE load access fault" (cause = 261).
. If `msipte` access detects a data corruption (a.k.a. poisoned data), then
  stop and report "MSI PT data corruption" (cause = 270).
. If `msipte.V == 0`, then stop and report "MSI PTE not valid" (cause = 262).
. If `msipte.C == 1`, then further processing to interpret the PTE is
  implementation defined.
. If `msipte.C == 0` then the process is outlined in subsequent steps.
. If `msipte.M == 0` or `msipte.M == 2`, then stop and report
  "MSI PTE misconfigured" (cause = 263).
. If `msipte.M == 3` the PTE is in basic translate mode and the translation
  process is as follows:
.. If any bits or encoding that are reserved for future standard use are set
   within `msipte`, stop and report "MSI PTE misconfigured" (cause = 263).
.. Compute the translated address as `msipte.PPN << 12 | A[11:0]`.
. If `msipte.M == 1` the PTE is in MRIF mode and the translation process
  is as follows:
.. If `capabilities.MSI_MRIF == 0`, stop and report "MSI PTE misconfigured"
   (cause = 263).
.. If any bits or encoding that are reserved for future standard use are
   set within `msipte`, stop and report "MSI PTE misconfigured" (cause = 263).
.. The address of the destination MRIF is `msipte.MRIF_Address[55:9] * 512`.
.. The destination address of the notice MSI is `msipte.NPPN << 12`.
.. Let `NID` be `(msipte.N10 << 10) | msipte.N[9:0]`. The data value for notice
   MSI is the 11-bit `NID` value zero-extended to 32-bits.
. The access permissions associated with the translation determined through this
  process are equivalent to that of a regular RISC-V G-stage PTE with
  `R`=`W`=`U`=1 and `X`=0. Similar to a G-stage PTE, when checking the `U` bit,
  the transaction is treated as not requesting supervisor privilege.
. If the transaction is a Untranslated or Translated read-for-execute then stop
  and report "Instruction guest page fault" (cause = 20).
. MSI address translation process is complete.

[NOTE]
====
In MRIF mode, the Advanced Interrupt Specification defines the operation to
store the incoming MSIs into the destination MRIF and to generate the notice
MSI. These operations may be performed by the IOMMU itself or the IOMMU may
provide the destination MRIF address, the notice MSI address, and the notice MSI
data value to the I/O bridge in response to the translation request and the
operations may be performed by the I/O bridge.
====

=== IOMMU updating of PTE accessed (A) and dirty (D) updates

When `capabilities.AMO` is 1, the IOMMU supports updating the A and D bits in
PTEs atomically. When updating of A and D bits in G-stage PTEs is enabled
(`DC.tc.GADE=1`) and/or updating of A and D bits in S/VS-stage PTEs is enabled
(`DC.tc.SADE=1`) the following rules apply:

. The A and/or D bit updates by the IOMMU must follow the rules specified by the
  Privileged specification for validity, permission checking, and atomicity.

. The PTE update must be globally visible before a memory access using the
  translated address provided by the IOMMU becomes globally visible.
  Specifically, when a translated address is provided to a device in an ATS
  Translation completion, the PTE update must be globally visible before a
  memory access from the device using the translated address becomes globally
  visible.

[NOTE]
====
The A and D bits are never cleared by the IOMMU. If the supervisor software does
not rely on accessed and/or dirty bits, e.g. if it does not swap memory pages to
secondary storage or if the pages are being used to map I/O space, it should
set them to 1 in the PTE to improve performance.
====

=== Faults from virtual address translation process

Faults detected during the S-stage or two-stage address translation specified
in the RISC-V Privileged specification cite:[PRIV] cause the IOVA translation process to stop and
report the detected fault.

[[ATS_FAULTS]]
=== PCIe ATS translation request handling
ATS cite:[PCI] translation requests that encounter a configuration error results in a
Completer Abort (CA) response to the requester. The following cause codes
belong to this category:

* Instruction access fault (cause = 1)
* Read access fault (cause = 5)
* Write/AMO access fault (cause = 7)
* MSI PTE load access fault (cause = 261)
* MSI PTE misconfigured (cause = 263)
* PDT entry load access fault (cause = 265)
* PDT entry misconfigured (cause = 267)

If there is a permanent error or if ATS transactions are disabled then an
Unsupported Request (UR) response is generated. The following cause codes
belong to this category:

* All inbound transactions disallowed (cause = 256)
* DDT entry load access fault (cause = 257)
* DDT entry not valid (cause = 258)
* DDT entry misconfigured (cause = 259)
* Transaction type disallowed (cause = 260)

When translation could not be completed due to the following causes a Success
Response with R and W bits set to 0 is generated. No faults are logged in
the fault queue on these errors. The translated address returned with such
completions is `UNSPECIFIED`.

* Instruction page fault (cause = 12)
* Read page fault (cause = 13)
* Write/AMO page fault (cause = 15)
* Instruction guest page fault (cause = 20)
* Read guest-page fault (cause = 21)
* Write/AMO guest-page fault (cause = 23)
* PDT entry not valid (cause = 266)
* MSI PTE not valid (cause = 262)

If the translation request has a PASID with "Privilege Mode Requested" field set
to 0, or the request does not have a PASID then the request does not target
privileged memory. If the U-bit that indicates if the memory is accessible to
user mode is 0 then a Success response with R and W bits set to 0 is generated.

If the translation request has a PASID with "Privilege Mode Requested" field set
to 1, then the request targets privileged memory. If the U-bit that indicates if
the page is accessible to user mode is 1 and the `SUM` bit in the `ta` field of the
process-context is 0 then a Success response with R and W bits set to 0 is
generated.

If the translation could be successfully completed but the requested
permissions are not present (Execute requested but no execute permission;
no-write not requested and no write permission; no read permission)
then a Success response is returned with the denied permission (R, W or X)
set to 0 and the other permission bits set to the value determined from the
page tables. The X permission is granted only if the R permission is also
granted. Execute-only translations are not compatible with PCIe ATS as PCIe
requires read permission to be granted if the execute permission is granted.

When a Success response is generated for an ATS translation request, no fault
records are reported to software through the fault/event reporting mechanism,
even when the response indicates no access was granted or some permissions were
denied.

If the translation request has an address determined to be an MSI address using
the rules defined by the <<MSI_ID>> but the MSI PTE is configured in MRIF
mode then a Success response is generated with R, W, and U bit set to 1. The U
bit being set to 1 in the response instructs the device that it must only use
Untranslated requests to access the implied 4 KiB memory range.

[NOTE]
====
When a MSI PTE is configured in MRIF mode, a MSI write with data value `D`
requires the IOMMU to set the interrupt-pending bit for interrupt identity `D`
in the MRIF. A translation request from a device to a GPA that is mapped
through a MRIF mode MSI PTE is not eligible to receive a translated address.
This is accomplished by setting "Untranslated Access Only" (U) field of the
returned response to 1.
====

When a Success response is generated for an ATS translation request, the setting
of the Priv, N, CXL.io, Global, and AMA fields is as follows:

* Priv field of the ATS translation completion is always set to 0 if the request
  does not have a PASID. When a PASID is present then the Priv field is set to
  the value in "Privilege Mode Requested" field as the permissions provided
  correspond to those the privilege mode indicate in the request.
* N field of the ATS translation completion is always set to 0. The device may
  use other means to determine if the No-snoop flag should be set in the
  translated requests.
* Global field is set to the value determined from the S/VS-stage page tables
  if translation could be successfully completed and the request had a PASID
  present. In all other cases, including MSI address translations, this field
  is set to 0.
* If requesting device is not a CXL device then CXL.io is set to 0.
* If requesting device is a CXL type 1 or type 2 device
** If the address is determined to be a MSI then the CXL.io bit is set to 1.
** Else if `T2GPA` is 1 in the device context then the CXL.io bit is set to 1.
** Else if the memory type, as determined by the Svpbmt extension, is NC or IO
   then the CXL.io bit is set to 1. If the memory type is PMA then the
   determination of the setting of this bit is `UNSPECIFIED`. If the Svpbmt
   extension is not supported then the setting of this bit is `UNSPECIFIED`.
** In all other cases the setting of this bit is `UNSPECIFIED`.
* The AMA field is by default set to 000b. The IOMMU may support an
  implementation-specific method to provide other encodings.

[NOTE]
====
The IO bridge may override the CXL.io bit in the ATS translation completion
based on the PMA of the translated address. Other implementations may provide
an implementation-defined method for determining PMA for the translated address
to set the CXL.io bit.

Use of `T2GPA` set to 1 may not be compatible with CXL type 1 or type 2 devices
as they use the CXL.cache protocol to implement caches tagged by the translated
address returned in response to a PCIe ATS Translation Request. The IOMMU may
not be invoked for translating addresses in CXL.cache transactions.
====


[[ATS_PRI]]
=== PCIe ATS Page Request handling
To process a "Page Request" or "Stop Marker" message cite:[PCI], the IOMMU first locates
the device-context to determine if ATS and PRI are enabled for the requester.
If ATS and PRI are enabled, i.e. `EN_ATS` and `EN_PRI` are both set to 1, the
 IOMMU queues the message into an in-memory queue called the
page-request-queue (`PQ`) (See <<PRQ>>). Following suitable processing of the
"Page Request", a software handler may generate a "Page Request Group Response"
message to the device.

When PRI is enabled for a device, the IOMMU may still be unable to report
"Page Request" or "Stop Marker" messages through the `PQ` due to error
conditions such as the queue being disabled, queue being full, or the IOMMU
encountering access faults when attempting to access queue memory. These error
conditions are specified in <<PRQ>>.

If the `ddtp.iommu_mode` is `Bare` or is `Off`, then the IOMMU cannot locate a
device-context for the requester.

If `EN_PRI` is set to 0, or `EN_ATS` is set to 0, or if the IOMMU is unable
to locate the `DC` to determine the `EN_PRI` configuration, or the request
could not be queued into `PQ` then the IOMMU behavior depends on the type
of "Page Request".

* If the "Page Request" does not require a response, i.e. the "Last Request in
  PRG" field of the message is set to 0, then such messages are silently
  discarded. "Stop Marker" messages do not require a response and are always
  silently discarded on such errors.
* If the "Page Request" needs a response, then the IOMMU itself may generate
  a "Page Request Group Response" message to the device.

When the IOMMU generates the response, the status field of the response depends
on the cause of the error.

The status is set to Response Failure if the following faults are encountered:

* `ddtp.iommu_mode` is `Off`
* DDT entry load access fault (cause = 257)
* DDT entry misconfigured (cause = 259)
* DDT entry not valid (cause = 258)
* Page-request queue is not enabled (`pqcsr.pqen == 0` or `pqcsr.pqon == 0`)
* Page-request queue encountered a memory access fault (`pqcsr.pqmf == 1`)

The status is set to Invalid Request if the following faults are encountered:

* `ddtp.iommu_mode` is `Bare`
* `EN_PRI` is set to 0

The status is set to Success if no other faults were encountered but the
"Page Request" could not be queued due to the page-request queue being full
(`pqh == pqt - 1`) or had a overflow (`pqcsr.pqof == 1`).

[NOTE]
====
When SR-IOV VF is used as a unit of allocation, a hypervisor may disable page
requests from one of the virtual functions by setting `EN_PRI` to 0. However the
page-request interface is shared by the PF and all VFs.  The IOMMU protocol
specific logic classifies this condition (cause = 260) as a non-catastrophic
failure, an Invalid Request, in its response to avoid the shared PRI in the
device being disabled for all PFs/VFs.
====

[NOTE]
====
A "Stop Marker" is encoded as a "Page Request" with a PASID but with the L, W,
and R fields set to 1, 0, and 0 respectively.
====

For IOMMU-generated "Page Request Group Response" messages that have status
Invalid Request or Success, the PRG-response-PASID-required (`PRPR`) bit when
set to 1 indicates that the IOMMU response message should include a PASID if the
associated "Page Request" had a PASID.

For IOMMU-generated "Page Request Group Response" with response code set to
Response Failure, if the "Page Request" had a PASID then response is generated
with a PASID.

No faults are logged in the fault queue for PCIe ATS "Page Request" messages for
the following conditions:

* Page-request queue is not enabled (`pqcsr.pqen == 0` or `pqcsr.pqon == 0`)
* Page-request queue encountered a memory access fault (`pqcsr.pqmf == 1`)
* "Page Request" could not be queued due to the page-request queue being full
  (`pqh == pqt - 1`) or had a overflow (`pqcsr.pqof == 1`).

[[CACHING]]
=== Caching in-memory data structures

To speed up Direct Memory Access (DMA) translations, the IOMMU may make use of
translation caches to hold entries from device-directory-table,
process-directory-table, S/VS and G-stage translation tables, and/or MSI page
tables. These caches are collectively referred to as the IOMMU Address
Translation Caches (IOATC).

This specification does not allow the caching of S/VS/G-stage PTEs whose `V`
(valid) bit is clear, non-leaf DDT entries whose `V` (valid) bit is clear,
Device-context whose `V` (valid) bit is clear, non-leaf PDT entries whose `V`
(valid) bit is clear, Process-context whose `V` (valid) bit is clear, or MSI
PTEs whose `V` bit is clear.

These IOATC do not observe modifications to the in-memory data structures using
explicit loads and stores by RISC-V harts or by device DMA. Software must use
the IOMMU commands to invalidate the cached data structure entries using IOMMU
commands to synchronize the IOMMU operations to observe updates to in-memory
data structures. A simpler implementation may not implement IOATC for some or
any of the in-memory data structures. The IOMMU commands may use one or
more IDs to tag the cached entries to identify a specific entry or a
group of entries.

.Identifiers used to tag IOATC entries
[width=90%]
[%header, cols="8,10,10"]
|===
|Data Structure cached  |IDs used to tag entries    | Invalidation command
|Device Directory Table |`device_id`                | <<IDDT, IODIR.INVAL_DDT>>
|Process Directory Table|`device_id`, `process_id`  | <<IPDT, IODIR.INVAL_PDT>>
|VS-stage page tables   |`GSCID`, `PSCID`, and IOVA | <<IVMA, IOTINVAL.VMA>>
|S-stage page tables    |`PSCID`, and IOVA          | <<IVMA, IOTINVAL.VMA>>
|G-stage page table     |`GSCID`, `GPA`             | <<IGVMA,IOTINVAL.GVMA>>
|MSI page table         |`GSCID`, `GPA`             | <<IGVMA,IOTINVAL.GVMA>>
|===

=== Updating in-memory data structure entries

The RISC-V memory model requires memory access from a hart to be single-copy
atomic. When RV32 is implemented the size of a single-copy atomic memory access
is up to 32-bits. When RV64 is implemented the size of a single-copy atomic
memory access is up to 64-bits. The size of a single-copy atomic memory access
implemented by the IOMMU is `UNSPECIFIED` but is required to be at least 32-bits
if all of the harts in the system implement RV32 and is required to be 64-bits
if any of the harts in the system implement RV64.

The IOMMU data structure entries have a `V` bit that when set to 1 indicates
that the entry is valid.

Software is allowed to make updates to a data structure entry that has the `V`
bit set to 1. However, some rules as outlined below must be followed.

* It is generally unsafe for software to update fields of a valid data structure
  entry using a set of stores of width less than the minimal single-copy atomic
  memory access supported by an IOMMU as it is legal for an IOMMU to read the
  entry at any time, including when only some of the partial stores have taken
  effect. +
+
* For an update to an IOMMU data structure entry to be atomic, software must use
  a single store of width equal to the minimal single-copy atomic memory access
  supported by an IOMMU. +
+
* If the update to a field will make the field inconsistent with another field
  of the entry then software must first set the `V` field to 0 and use the commands
  outlined in <<CACHING>> to invalidate any previous copies of that entry that
  may be in IOMMU caches before updating other fields of that entry. +
+
* The IOMMU is not required to immediately observe the software update to an
  entry. Software must use the commands outlined in <<CACHING>> to invalidate
  any previous copies of that entry that may be in IOMMU caches to synchronize
  the updates to the entry with the operation of the IOMMU.

[NOTE]
====
If a data structure entry is changed, the IOMMU may use the old value of the
entry or the new value of the entry and the choice is unpredictable until
software uses the commands outlined in <<CACHING>> to invalidate any previous
copies of that entry that may be in IOMMU caches to synchronize updates to the
entry with the operation of the IOMMU. These are the only behaviors expected.
====

=== Endianness of in-memory data structures

The RISC-V memory model specifies byte-invariance for the entire address space.
When mixed-endian mode of operation is supported, the IO bridge and the IOMMU
must implement byte-invariant addressing such that a byte access to a given
address accesses the same memory location in both little-endian and big-endian
mode of operation.

The endianness of implicit memory access to in-memory data structures is
determined by `fctl.BE` or by `DC.tc.SBE` as follows:

[[ENDIAN_CONFIG]]
.Endianness of memory access to data structures
[width=75%]
[%header, cols="16,8"]
|===
^|Data Structure             ^| Controlled by
| Device directory table     | `fctl.BE`
| G-stage page table         | `fctl.BE`
| MSI page table             | `fctl.BE`
| Process directory Table    | `DC.tc.SBE`
| S/VS-stage page table      | `DC.tc.SBE`
|===

[NOTE]
====
The `PSCID` field of first-stage context, along with the `GSCID` (when two-stage
address translation is active), identifies an address space. Configuring an
identical `GSCID` and `PSCID` in two DC but with different `SBE` is not expected
and if done may lead to the IOMMU interpreting a S/VS-stage PTE as big-endian
or little-endian. These are the only behaviors expected.
====

[NOTE]
====
Software must use an appropriate software sequence to swap bytes as necessary to
create a mutually agreed to data representation when sharing data with an IO
agent that does not share its endianness. Software must use an LR/SC sequence to
perform atomic operations in non-native endian format when the data shared with
such IO agents must be accessed atomically.
====
