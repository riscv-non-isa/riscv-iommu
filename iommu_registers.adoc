== Memory-mapped register interface

The IOMMU provides a memory-mapped programming interface. The memory-mapped 
registers of each IOMMU are located within a naturally aligned 4-KiB region 
(a page) of physical address space. 

The IOMMU behavior for register accesses where the address is not aligned to 
the size of the access, or if the access spans multiple registers, of if the
size of the access is not 4 bytes or 8 bytes, is `UNSPECIFIED`. The atomicity
of access to a 8 byte register is `UNSPECIFIED`. The implementation may
observe the 8 byte access as two 4 byte accesses. A 4 byte access to an IOMMU
register must be single-copy atomic.

[NOTE]
====
If an implementation may observe a 8 byte register access as two 4 byte
accesses then such implementations must preserve the semantics of the 8 byte
access and must cause any side effects only after both accesses have been
observed.
====

The IOMMU registers have little-endian byte order (even for systems where
all harts are big-endian-only).

[NOTE]
====
Big-endian-configured harts that make use of an IOMMU are expected to implement
the `REV8` byte-reversal instruction defined by the Zbb extension. If `REV8` is 
not implemented, then endianness conversion may be implemented using a sequence
of instructions.
====

If a register is optional, as determined by the corresponding `capabilities`
register bit being 0, then a read from the memory mapped register offset of 
the register returns 0 and writes to that offset are ignored.

=== Register layout

.IOMMU Memory-mapped register layout
[width=100%]
[%header, cols="^3,6,^3, 12, 10"]
|===
|Offset|Name            |Size|Description                 | Is Optional?
|0     |`capabilities`  |8   |<<CAP, Capabilities of the
                                     IOMMU>>              | No
|8     |`fctl`          |4   |<<FCTRL, Features control>> | No
|12    |_custom_        |4   |_Designated For custom use_ |
|16    |`ddtp`          |8   |<<DDTP, Device directory
                              table pointer>>             | No
|24    |`cqb`           |8   |<<CQB, Command-queue base>> | No
|32    |`cqh`           |4   |<<CQH, Command-queue head>> | No
|36    |`cqt`           |4   |<<CQT, Command-queue tail>> | No
|40    |`fqb`           |8   |<<FQB, Fault-queue base>>   | No
|48    |`fqh`           |4   |<<FQH, Fault-queue head>>   | No
|52    |`fqt`           |4   |<<FQT, Fault-queue tail>>   | No
|56    |`pqb`           |8   |<<PQB, Page-request-queue
                                     base>>               | if `capabilities.ATS==0`
|64    |`pqh`           |4   |<<PQH, Page-request-queue
                                     head>>               | if `capabilities.ATS==0`
|68    |`pqt`           |4   |<<PQT, Page-request-queue
                                     tail>>               | if `capabilities.ATS==0`
|72    |`cqcsr`         |4   |<<CSR, Command-queue CSR>>  | No
|76    |`fqcsr`         |4   |<<FQCSR, Fault-queue CSR>>  | No
|80    |`pqcsr`         |4   |<<PQCSR, Page-request-queue
                                       CSR >>             | if `capabilities.ATS==0`
|84    |`ipsr`          |4   |<<IPSR, Interrupt pending
                                         status register>>| No
|88    |`iocntovf`      |4   |<<OVF, HPM counter overflows>> | if `capabilities.HPM==0`
|92    |`iocntinh`      |4   |<<INH, HPM counter inhibits>> | if `capabilities.HPM==0`
|96    |`iohpmcycles`   |8   |<<CYC, HPM cycles counter>> | if `capabilities.HPM==0`
|104   |`iohpmctr1-31`  |248 |<<CTR, HPM event counters>> | if `capabilities.HPM==0`
|352   |`iohpmevt1-31`  |248 |<<EVT, HPM event selector>> | if `capabilities.HPM==0`
|600   |`tr_req_iova`   |8   |<<TRR_IOVA, Translation-request
                                     IOVA>>               | if `capabilities.DBG==0`
|608   |`tr_req_ctl`    |8   |<<TRR_CTRL, Translation-request
                                     control>>            | if `capabilities.DBG==0`
|616   |`tr_response`   |8   |<<TRR_RSP,Translation-request
                                     response>>           | if `capabilities.DBG==0`
|624   |Reserved        |64  |Reserved for future use
                              (`WPRI`)                    |
|688   |_custom_        |72  |_Designated for custom use
                              (`WARL`)_                   |
|760   |`icvec`         |4   |<<ICVEC, Interrupt cause
                              to vector register>>        | No
|768   |`msi_cfg_tbl`   |256 |<<MSI, MSI Configuration
                                     Table>>              | if `capabilities.IGS==WSI`
|1024  |Reserved        |3072|Reserved for standard use   |
|===

=== Reset behavior
The reset value is 0 for the following registers/fields.

* `fctl`
* `cqcsr`
* `fqcsr`
* `pqcsr`

Reset value for `ddtp.iommu_mode` field must be either `Off` or `Bare`. The 
reset value for `ddtp.busy` field must be 0.

Reset value for `tr_req_ctl.Go/Busy` field must be 0.

After a reset the caches (<<CACHING>>) must have no valid entries.

[NOTE]
====
The reset value for the `iommu_mode` is recommended to be `Off`.
====

Reset value is `UNSPECIFIED` for all other registers and/or fields.

[[CAP]]
=== IOMMU capabilities (`capabilities`)

The `capabilities` register is a read-only register reporting features supported
by the IOMMU. Each field if not clear indicates presence of that feature in 
the IOMMU. At reset, the register shall contain the IOMMU supported features.

.IOMMU capabilities register fields
[wavedrom, , ]
....
{reg: [
  {bits: 8, name: 'version'},
  {bits: 1, name: 'Sv32'},
  {bits: 1, name: 'Sv39'},
  {bits: 1, name: 'Sv48'},
  {bits: 1, name: 'Sv57'},
  {bits: 2, name: 'reserved'},
  {bits: 1, name: 'Svnapot'},
  {bits: 1, name: 'Svpbmt'},
  {bits: 1, name: 'Sv32x4'},
  {bits: 1, name: 'Sv39x4'},
  {bits: 1, name: 'Sv48x4'},
  {bits: 1, name: 'Sv57x4'},
  {bits: 2, name: 'reserved'},
  {bits: 1, name: 'MSI_FLAT'},
  {bits: 1, name: 'MSI_MRIF'},
  {bits: 1, name: 'AMO'},
  {bits: 1, name: 'ATS'},
  {bits: 1, name: 'T2GPA'},
  {bits: 1, name: 'END'},
  {bits: 2, name: 'IGS'},
  {bits: 1, name: 'HPM'},
  {bits: 1, name: 'DBG'},
  {bits: 6, name: 'PAS'},
  {bits: 1, name: 'PD8'},
  {bits: 1, name: 'PD17'},
  {bits: 1, name: 'PD20'},
  {bits: 15, name: 'reserved'},
  {bits: 8, name: 'custom'},
], config:{lanes: 8, hspace:1024}}
....

[width=100%]
[%header, cols="1,2,1,5"]
|===
|Bits  |Field      |Attribute | Description
|7:0   |`version`  |RO        | The `version` field holds the version of the 
                                specification implemented by the IOMMU. The low
                                nibble is used to hold the minor version of the
                                specification and the upper nibble is used to 
                                hold the major version of the specification. 
                                For example, an implementation that supports 
                                version 1.0 of the specification reports 0x10.
|8     |`Sv32`     |RO        | Page-based 32-bit virtual addressing is supported.
|9     |`Sv39`     |RO        | Page-based 39-bit virtual addressing is supported.
|10    |`Sv48`     |RO        | Page-based 48-bit virtual addressing is supported. +
                                When `Sv48` field is set, `Sv39` field must be set.
|11    |`Sv57`     |RO        | Page-based 57-bit virtual addressing is supported +
                                When `Sv57` field is set, `Sv48` field must be set.
|13:12 | reserved  |RO        | Reserved for standard use.
|14    |`Svnapot`  |RO        | NAPOT translation contiguity.
|15    |`Svpbmt`   |RO        | Page-based memory types.
|16    |`Sv32x4`   |RO        | Page-based 34-bit virtual addressing for G-stage
                                translation is supported.
|17    |`Sv39x4`   |RO        | Page-based 41-bit virtual addressing for G-stage
                                translation is supported.
|18    |`Sv48x4`   |RO        | Page-based 50-bit virtual addressing for G-stage
                                translation is supported.
|19    |`Sv57x4`   |RO        | Page-based 59-bit virtual addressing for G-stage
                                translation is supported.
|21:20 | reserved  |RO        | Reserved for standard use.
|22    |`MSI_FLAT` |RO        | MSI address translation using Pass-through
                                mode MSI PTE is supported.
|23    |`MSI_MRIF` |RO        | MSI address translation using MRIF mode MSI PTE
                                is supported.
|24    |`AMO`      |RO        | Atomic updates to MRIF and PTE accessed (A) 
                                and dirty (D) bit is supported.
|25    |`ATS`      |RO        | PCIe Address Translation Services (ATS) and 
                                page-request interface (PRI) is supported.
|26    |`T2GPA`    |RO        | Returning guest-physical-address in ATS 
                                translation completions is supported.
|27    |`END`       |RO       | When 0, IOMMU supports one endianness (either little
                                or big). When 1, IOMMU supports both endianness.
                                The endianness is defined in `fctl` register.
|29:28 |`IGS`      |RO       a| IOMMU interrupt generation support.

[%header, cols="^1,1,3"]
!===
                                !Value  !Name      ! Description
                                !0      ! `MSI`    ! IOMMU supports only message-
                                                     signaled-interrupt generation.
                                !1      ! `WSI`    ! IOMMU supports only wire-
                                                     signaled-interrupt generation.
                                !2      ! `BOTH`   ! IOMMU supports both MSI 
                                                     and WSI generation.
                                                     The interrupt generation method
                                                     must be defined in `fctl`
                                                     register.
                                !3      ! 0        ! Reserved for standard use
!===

|30    |`HPM`     |RO         | IOMMU implements a hardware performance monitor.
|31    |`DBG`      |RO        | IOMMU supports the translation-request interface
|37:32 |`PAS`      |RO        | Physical Address Size (value between 32 and 56)
|38    |`PD8`      |RO        | One level PDT with 8-bit process_id supported.
|39    |`PD17`     |RO        | Two level PDT with 17-bit process_id supported.
|40    |`PD20`     |RO        | Three level PDT with 20-bit process_id supported.
|55:41 | reserved  |RO        | Reserved for standard use
|63:56 |_custom_   |RO        | _Designated for custom use_
|===

If `HPM` is supported then the IOMMU must implement the cycles counter and at
least 1 hardware performance monitoring counter must be implemented.

At least one method, `MSI` or `WSI`, of generating interrupts from the IOMMU
must be supported.

[NOTE]
====
Hypervisor may provide an SW emulated IOMMU to allow the guest to manage 
the VS-stage page tables for fine grained control on memory accessed by guest 
controlled devices. 

A hypervisor that provides such an emulated IOMMU to the guest may retain 
control of the G-stage page tables and clear the `SvNx4` fields of the 
emulated `capabilities` register.

A hypervisor that provides such an emulated IOMMU to the guest may retain 
control of the MSI page tables used to direct MSI to guest interrupt files in 
an IMSIC or to a memory-resident-interrupt-file and clear the `MSI_FLAT` and 
`MSI_MRIF` fields of the emulated `capabilities` register.
====

[NOTE]
====
The `AMO` bit does not indicate support for device initiated atomic memory
operations. Support for device initiated atomic memory operations must be
discovered through other means.
====

[[FCTRL]]
=== Features-control register (`fctl`)

This register must be readable in any implementation. An implementation may 
allow one or more fields in the register to be writable to support enabling
or disabling the feature controlled by that field.

If software enables or disables a feature when the IOMMU is not OFF 
(i.e. `ddtp.iommu_mode == Off`) then the IOMMU behavior is `UNSPECIFIED`.

If software enables or disables a feature when the IOMMU in-memory queues
are enabled (i.e. `cqcsr.cqon/cqen == 1`, `fqcsr.fqon/cqen == 1`, or 
`pqcsr.pqon/pqen == 1`) then the IOMMU behavior is `UNSPECIFIED`.

.Feature-control register fields
[wavedrom, , ]
....
{reg: [
  {bits: 1, name: 'BE'},
  {bits: 1, name: 'WSI'},
  {bits: 1, name: 'ADFD'},
  {bits: 13,  name: 'reserved'},
  {bits: 16,  name: 'custom'},
], config:{lanes: 1, hspace:1024}}
....

[width=100%]
[%header, cols="^1,2,^1,5"]
|===
|Bits  |Field      |Attribute | Description
|0     |`BE`       |WARL      | When 0, IOMMU accesses to memory resident data 
                                structures (e.g. DDT, PDT, in-memory queues, 
                                S/VS and G stage page tables) are performed as 
                                little-endian accesses and when 1 as 
                                big-endian accesses.
|1     |`WSI`      |WARL      | When 1, IOMMU interrupts are signaled as 
                                wire-signaled-interrupts.
|2     |`ADFD`     |WARL      | When 1, IOMMU faults due to A/D bits is
                                disabled.
|15:3  |`reserved` |WPRI      | Reserved for standard use.
|31:16 |_custom_   |WPRI      | _Designated for custom use._
|===

[[DDTP]]
=== Device-directory-table pointer (`ddtp`)
.Device-directory-table pointer register fields
[wavedrom, , ]
....
{reg: [
  {bits: 4,  name: 'iommu_mode'},
  {bits: 1,  name: 'busy'},
  {bits: 5, name: 'reserved'},
  {bits: 44, name: 'PPN'},
  {bits: 10, name: 'reserved'},
], config:{lanes: 4, hspace:1024}}
....

[width=100%]
[%header, cols="^1,2,^1,5"]
|===
|Bits  |Field      |Attribute | Description
|3:0   |`iommu_mode` |WARL   a| The IOMMU may be configured to be in following
                                modes:
[%header, cols="^1,1,3"]
!===
                                !Value  !Name      ! Description
                                !0      ! `Off`    ! No inbound memory 
                                                     transactions are allowed 
                                                     by the IOMMU.
                                !1      ! `Bare`   ! No translation or 
                                                     protection. All inbound 
                                                     memory accesses are passed
                                                     through.
                                !2      ! `1LVL`   ! One-level 
                                                     device-directory-table
                                !3      ! `2LVL`   ! Two-level 
                                                     device-directory-table
                                !4      ! `3LVL`   ! Three-level 
                                                     device-directory-table
!===
|4     |`busy`     |RO        | A write to `ddtp` may require the IOMMU to 
                                perform many operations that may not occur 
                                synchronously to the write. When a write is 
                                observed by the `ddtp`, the `busy` bit is set 
                                to 1. When the `busy` bit is 1, behavior of 
                                additional writes to the `ddtp` is 
                                `UNSPECIFIED`. Some implementations 
                                may ignore the second write and others may 
                                perform the actions determined by the second 
                                write. Software must verify that the `busy` 
                                bit is 0 before writing to the `ddtp`. +
                                                                               +
                                If the `busy` bit reads 0 then the IOMMU has 
                                completed the operations associated with the 
                                previous write to `ddtp`. +
                                                                               +
                                An IOMMU that can complete these operations 
                                synchronously may hard-wire this bit to 0.
|9:5   |`reserved` |WPRI      | Reserved for standard use
|53:10 |`PPN`      |WARL      | Holds the `PPN` of the root page of the 
                                device-directory-table.
|63:54 |`reserved` |WPRI      | Reserved for standard use
|===

The device-context is 64-bytes in size if `capabilities.MSI_FLAT` is 1 else it is 
32-bytes.

When the `iommu_mode` is `Bare` or `Off`, the `PPN` field is don't-care. When 
in `Bare` mode only Untranslated requests are allowed. Translated requests, 
Translation request, and message transactions are unsupported.

All IOMMU must support `Off` and `Bare` mode. An IOMMU is allowed to support a 
subset of directory-table levels and device-context widths. At a minimum one 
of the modes must be supported.

When the `iommu_mode` field value is changed to `Off` the IOMMU guarantees that 
in-flight transactions from devices connected to the IOMMU will be processed 
with the configurations applicable to the old value of the `iommu_mode` field 
and that all transactions and previous requests from devices that have already 
been processed by the IOMMU be committed to a global ordering point such that 
they can be observed by all RISC-V hart, devices, and IOMMUs in the platform.

The IOMMU behavior of writing `iommu_mode` to `1LVL`, `2LVL`, or `3LVL`, when
the previous value of the `iommu_mode` is not `Off` or `Bare` is `UNSPECIFIED`.
To change DDT levels, the IOMMU must first be transitioned to `Bare` or `Off` 
state.

When an IOMMU is transitioned to `Bare` of `Off` state, the IOMMU may retain
information cached from in-memory data structures such as page tables, DDT,
PDT, etc. Software must use suitable invalidation commands to invalidate cached
entries.

[NOTE]
====
In RV32, only the low order 32-bits of the register (22-bit `PPN` and 
4-bit `iommu_mode`) need to be written.
====

[[CQB]]
=== Command-queue base (`cqb`)

This 64-bits register (RW) holds the PPN of the root page of the command-queue
and number of entries in the queue. Each command is 16 bytes.

.Command-queue base register fields
[wavedrom, , ]
....
{reg: [
  {bits:  5, name: 'LOG2SZ-1'},
  {bits: 5, name: 'reserved'},
  {bits: 44, name: 'PPN'},
  {bits: 10, name: 'reserved'},
], config:{lanes: 2, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits  |Field      |Attribute | Description
|4:0   |`LOG2SZ-1` |WARL     a| The `LOG2SZ-1` field holds the number of 
                                entries in command-queue as a log to base 2 
                                minus 1. 
                                A value of 0 indicates a queue of 2 entries.
                                Each IOMMU command is 16-bytes. 
                                If the command-queue has 256 or fewer entries 
                                then the base address of the queue is always 
                                aligned to 4-KiB. If the command-queue has more
                                than 256 entries then the command-queue 
                                base address must be naturally aligned to 
                                `2^LOG2SZ^ x 16`.
|9:5   |`reserved` |WPRI      | Reserved for standard use
|53:10 |`PPN`      |WARL      | Holds the `PPN` of the root page of the 
                                in-memory command-queue used by software to 
                                queue commands to the IOMMU. If the base 
                                address as determined by `PPN` is not aligned
                                as required, all entries in the queue appear
                                to an IOMMU as `UNSPECIFIED` and any address
                                an IOMMU may compute and use for accessing an
                                entry in the queue is also `UNSPECIFIED`.
|63:54 |`reserved` |WPRI      | Reserved for standard use
|===

[NOTE]
====
In RV32, only the low order 32-bits of the register (22-bit `PPN` and 
5-bit `LOG2SZ-1`) need to be written.
====

[[CQH]]
=== Command-queue head (`cqh`)

This 32-bits register (RO) holds the index into the command-queue where 
the IOMMU will fetch the next command.

.Command-queue head register fields
[wavedrom, , ]
....
{reg: [
  {bits: 32, name: 'index'},
], config:{lanes: 1, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits |Field   |Attribute | Description
|31:0 |`index` |RO        | Holds the `index` into the command-queue from where
                            the next command will be fetched next by the IOMMU.
|===

[[CQT]]
=== Command-queue tail (`cqt`)

This 32-bits register (RW) holds the index into the command-queue where 
the software queues the next command for the IOMMU.

.Command-queue tail register fields
[wavedrom, , ]
....
{reg: [
  {bits: 32, name: 'index'},
], config:{lanes: 1, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits |Field   |Attribute | Description
|31:0 |`index` |WARL      | Holds the `index` into the command-queue where 
                            software queues the next command for IOMMU.  Only 
                            `LOG2SZ-1:0` bits are writable.
|===

[[FQB]]
=== Fault queue base (`fqb`)

This 64-bits register (RW) holds the PPN of the root page of the fault-queue
and number of entries in the queue. Each fault record is 32 bytes.

.Fault queue base register fields

[wavedrom, , ]
....
{reg: [
  {bits: 5, name: 'LOG2SZ-1'},
  {bits: 5, name: 'reserved'},
  {bits: 44, name: 'PPN'},
  {bits: 10, name: 'reserved'},
], config:{lanes: 2, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits  |Field     |Attribute | Description
|4:0   |`LOG2SZ-1`|WARL     a| The `LOG2SZ-1` field holds the number of 
                               entries in fault-queue as a log-to-base-2 
                               minus 1. A value of 0 indicates a queue of 2 
                               entries. Each fault record is 32-bytes. 
                               If the fault-queue has 128 or fewer entries then 
                               the base address of the queue is always aligned 
                               to 4-KiB. If the fault-queue has more than 128 
                               entries then the fault-queue base address must 
                               be naturally aligned to `2^LOG2SZ^ x 32`.
| 9:5  |`reserved`|WPRI       | Reserved for standard use
|53:10 |`PPN`     |WARL      | Holds the `PPN` of the root page of the 
                               in-memory fault-queue used by IOMMU to queue 
                               fault record. if the base address as determined 
                               by `PPN` is not aligned as required, all entries
                               in the queue appear to an IOMMU as `UNSPECIFIED`
                               and any address an IOMMU may compute and use for
                               accessing an entry in the queue is also 
                               `UNSPECIFIED`.
|63:54 |`reserved`|WPRI       | Reserved for standard use
|===

[NOTE]
====
In RV32, only the low order 32-bits of the register (22-bit `PPN` and 
5-bit `LOG2SZ-1`) need to be written.
====

[[FQH]]
=== Fault queue head (`fqh`)

This 32-bits register (RW) holds the index into fault-queue where the
software will fetch the next fault record.

.Fault queue head register fields

[wavedrom, , ]
....
{reg: [
  {bits: 32, name: 'index'},
], config:{lanes: 1, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits |Field   |Attribute |Description
|31:0 |`index` |WARL      | Holds the `index` into the fault-queue from which 
                            software reads the next fault record.  Only 
                            `LOG2SZ-1:0` bits are writable.
|===

[[FQT]]
=== Fault queue tail (`fqt`)

This 32-bits register (RO) holds the index into the fault-queue where the
IOMMU queues the next fault record.

.Fault queue tail register fields

[wavedrom, , ]
....
{reg: [
  {bits: 32, name: 'index'},
], config:{lanes: 1, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits |Field   |Attribute | Description
|31:0 |`index` |RO        | Holds the `index` into the fault-queue where IOMMU 
                            writes the next fault record.
|===

[[PQB]]
=== Page-request-queue base (`pqb`)

This 64-bits register (RW) holds the PPN of the root page of the 
page-request-queue and number of entries in the queue. Each page-request
message is 16 bytes.

.Page-Request-queue base register fields

[wavedrom, , ]
....
{reg: [
  {bits: 5, name: 'LOG2SZ-1'},
  {bits:  5, name: 'reserved'},
  {bits: 44, name: 'PPN'},
  {bits: 10, name: 'reserved'},
], config:{lanes: 2, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits  |Field     |Attribute | Description
|4:0   |`LOG2SZ-1`|WARL      | The `LOG2SZ-1` field holds the number of entries 
                               in page-request-queue as a log-to-base-2 minus 1.
                               A value of 0 indicates a queue of 2 entries. 
                               Each page-request is 16-bytes. If the 
                               page-request-queue has 256 or fewer entries 
                               then the base address of the queue is always 
                               aligned to 4-KiB.
                               If the page-request-queue has more than 256 
                               entries then the page-request-queue base address
                               must be naturally aligned to `2^LOG2SZ^ x 16`.
| 9:5  |`reserved`|WPRI      | Reserved for standard use
|53:10 |`PPN`     |WARL      | Holds the `PPN` of the root page of the 
                               in-memory page-request-queue used by IOMMU to 
                               queue "Page Request" messages. If the base 
                               address as determined by `PPN` is not aligned as
                               required, all entries in the queue appear to an
                               IOMMU as `UNSPECIFIED` and any address an IOMMU
                               may compute and use for accessing an entry in the
                               queue is also `UNSPECIFIED`.
|63:54 |`reserved`|WPRI      | Reserved for standard use
|===

[NOTE]
====
In RV32, only the low order 32-bits of the register (22-bit `PPN` and 
5-bit `LOG2SZ-1`) need to be written.
====

[[PQH]]
=== Page-request-queue head (`pqh`)

This 32-bits register (RW) holds the index into the page-request-queue where
software will fetch the next page-request.

.Page-request-queue head register fields

[wavedrom, , ]
....
{reg: [
  {bits: 32, name: 'index'},
], config:{lanes: 1, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits |Field   |Attribute | Description
|31:0 |`index` |WARL      | Holds the `index` into the page-request-queue from 
                            which software reads the next "Page Request" message.
                            Only `LOG2SZ-1:0` bits are writable.
|===

[[PQT]]
=== Page-request-queue tail (`pqt`)

This 32-bits register (RO) holds the index into the page-request-queue 
where the IOMMU writes the next page-request.

.Page-request-queue tail register fields

[wavedrom, , ]
....
{reg: [
  {bits: 32, name: 'index'},
], config:{lanes: 1, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits |Field   |Attribute | Description
|31:0 |`index` |RO        | Holds the `index` into the page-request-queue 
                            where IOMMU writes the next "Page Request" message.
|===

[[CSR]]
=== Command-queue CSR (`cqcsr`)

This 32-bits register (RW) is used to control the operations and report the
status of the command-queue.

.Command-queue CSR register fields
[wavedrom, , ]
....
{reg: [
  {bits: 1, name: 'cqen'},
  {bits: 1, name: 'cie'},
  {bits: 6, name: 'reserved'},
  {bits: 1, name: 'cqmf'},
  {bits: 1, name: 'cmd_to'},
  {bits: 1, name: 'cmd_ill'},
  {bits: 1, name: 'fence_w_ip'},
  {bits: 4, name: 'reserved'},
  {bits: 1, name: 'cqon'},
  {bits: 1, name: 'busy'},
  {bits: 10, name: 'reserved'},
  {bits: 4, name: 'custom'},
], config:{lanes: 4, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits |Field   |Attribute | Description
|0    |`cqen`  |RW        | The command-queue-enable bit enables the command-
                            queue when set to 1. Changing `cqen` from 0 to 1
                            sets the `cqh` and `cqt` to 0. The command-queue 
                            may take some time to be active following setting 
                            the `cqen` to 1. When the command queue is active,
                            the `cqon` bit reads 1. +
                                                                              +
                            When `cqen` is changed from 1 to 0, the command 
                            queue may stay active till the commands already 
                            fetched from the command-queue are being processed 
                            and/or there are outstanding implicit loads from 
                            the command-queue.  When the command-queue turns 
                            off, the `cqon` bit reads 0, `cqh` is set to 0, 
                            `cqt` is set to 0 and the `cqcsr` bits `cmd_ill`, 
                            `cmd_to`, `cqmf`, `fence_w_ip` are set to 0. +
                                                                              +
                            When the `cqon` bit reads 0, the IOMMU guarantees 
                            that no implicit memory accesses to the command 
                            queue are in-flight and the command-queue will not 
                            generate new implicit loads to the queue memory. 
|1    |`cie`   |RW        | Command-queue-interrupt-enable bit enables 
                            generation of interrupts from command-queue when 
                            set to 1.
|7:2  |`reserved`|WPRI    | Reserved for standard use
|8    |`cqmf`  |RW1C      | If command-queue access leads to a memory fault then
                            the command-queue-memory-fault bit is set to 1 and 
                            the command-queue stalls until this bit is cleared. 
                            When `cqmf` is set to 1, an interrupt is generated 
                            if an interrupt is not already pending 
                            (i.e., `ipsr.cip == 1`) and not masked 
                            (i.e. `cqsr.cie == 0`). To re-enable command 
                            processing, software should clear this bit by 
                            writing 1. 
|9    |`cmd_to`|RW1C      | If the execution of a command leads to a 
                            timeout (e.g. a command to invalidate device ATC 
                            may timeout waiting for a completion), then the 
                            command-queue sets the `cmd_to` bit and stops 
                            processing from the command-queue. When `cmd_to` is
                            set to 1 an interrupt is generated if an interrupt 
                            is not already pending (i.e., `ipsr.cip == 1`) and 
                            not masked (i.e. `cqsr.cie == 0`). To re-enable 
                            command processing software should clear this bit 
                            by writing 1. 
|10   |`cmd_ill`|RW1C     | If an illegal or unsupported command is fetched and
                            decoded by the command-queue then the command-queue 
                            sets the `cmd_ill` bit and stops processing from the
                            command-queue. When `cmd_ill` is set to 1, 
                            an interrupt is generated if not already pending 
                            (i.e. `ipsr.cip == 1`) and not masked 
                            (i.e.  `cqsr.cie == 0`). To re-enable command 
                            processing software should clear this bit by 
                            writing 1. 
|11   |`fence_w_ip`|RW1C  | An IOMMU that supports only wire-signaled-interrupts
                            sets `fence_w_ip` bit is set to indicate completion
                            of an `IOFENCE.C` command. An interrupt on setting 
                            `fence_w_ip` if not already pending 
                            (i.e. `ipsr.cip == 1`) and `fence_w_ip` is 0. 
                            To re-enable interrupts on `IOFENCE.C` completion
                            software should clear this bit by writing 1.
                            This bit is reserved if the IOMMU does not support
                            wire-signaled-interrupts or wire-signaled-interrupts
                            are not enabled (i.e., `fctl.WSI == 0`).
|15:12|`reserved`|WPRI    | Reserved for standard use
|16   |`cqon`   |RO       | The command-queue is active if `cqon` is 1.
                            IOMMU behavior on changing `cqb` when `busy` is 1 or 
                            `cqon` is 1 is `UNSPECIFIED`. The software 
                            recommended sequence to change `cqb` is to first 
                            disable the command-queue by clearing `cqen` and 
                            waiting for both `busy` and `cqon` to be 0 before 
                            changing the `cqb`.
|17   |`busy`   |RO       | A write to `cqcsr` may require the IOMMU to perform
                            many operations that may not occur synchronously 
                            to the write. When a write is observed by the 
                            `cqcsr`, the `busy` bit is set to 1. +
                                                                               +
                            When the `busy` bit is 1, behavior of additional 
                            writes to the `cqcsr` is `UNSPECIFIED`. 
                            Some implementations may ignore the second write and
                            others may perform the actions determined by the 
                            second write. +
                                                                               +
                            Software must verify that the busy bit is 0 before 
                            writing to the `cqcsr`. +
                                                                               +
                            An IOMMU that can complete these operations 
                            synchronously may hard-wire this bit to 0.
|27:18 |`reserved`|WPRI  | Reserved for standard use
|31:28 |_custom_  |WPRI  | _Designated for custom use._
|===

When `cmd_ill` or `cqmf` is 1 in `cqcsr` the `cqt` references the command in the
CQ that caused these error. Previous commands may have completed, timed out, or
their execution aborted by the IOMMU.

[NOTE]
====
If software makes the CQ operational again after a `cmd_ill` or `cqmf` error,
then software should resubmit the commands submitted since the last `IOFENCE.C`
that successfully completed.
====

The `cmd_to` bit is set when a `IOFENCE.C` command detects that one or more
previous commands that are specified to have timeouts have timed out but all
other commands previous to the `IOFENCE.C` have completed. When `cmd_to` is 1
`cqt` references the `IOFENCE.C` command that detected the timeout.

[NOTE]
====
Command-queue being empty does not imply that all commands fetched from the 
command-queue have been completed. When the command-queue is requested to be 
disabled, an implementation may either complete the already fetched commands 
or abort execution of those commands. Software must use an `IOFENCE.C` command 
to wait for all previous commands to be committed, if so desired, before 
turning off the command-queue.
====

[[FQCSR]]
=== Fault queue CSR (`fqcsr`)

This 32-bits register (RW) is used to control the operations and report the
status of the fault-queue.

.Fault queue CSR register fields

[wavedrom, , ]
....
{reg: [
  {bits: 1, name: 'fqen'},
  {bits: 1, name: 'fie'},
  {bits: 6, name: 'reserved'},
  {bits: 1, name: 'fqmf'},
  {bits: 1, name: 'fqof'},
  {bits: 6, name: 'reserved'},
  {bits: 1, name: 'fqon'},
  {bits: 1, name: 'busy'},
  {bits: 10, name: 'reserved'},
  {bits: 4, name: 'custom'},
], config:{lanes: 4, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits  |Field |Attribute | Description
|0     |`fqen`|RW        | The fault-queue enable bit enables the fault-queue 
                           when set to 1. +
                                                                               +
                           Changing `fqen`  from 0 to 1, resets the `fqh` and 
                           `fqt` to 0.
                           The fault-queue may take some time to be active
                           following setting the `fqen` to 1. When the fault 
                           queue is active, the `fqon` bit reads 1. +
                                                                               +
                           When `fqen` is changed from 1 to 0, the fault-queue 
                           may stay active till in-flight fault-recording is 
                           completed. When the fault-queue is off, the `fqon` 
                           bit reads 0, the `fqon` bit reads 0, `fqh` is set to
                           0, `fqt` is set to 0 and the `fqcsr` bits `fqof`, and
                           `fqmf` are set to 0. +
                                                                               +
                           The IOMMU guarantees that there are no 
                           in-flight implicit writes to the fault-queue in 
                           progress when `fqon` reads 0 and no new fault 
                           records will be written to the fault-queue. 
|1     |`fie` |RW        | Fault queue interrupt enable bit enables generation 
                           of interrupts from fault-queue when set to 1.
|7:2   |`reserved`|WPRI  | Reserved for standard use
|8     |`fqmf`|RW1C      | The `fqmf` bit is set to 1 if the IOMMU encounters 
                           an access fault when storing a fault record to the 
                           fault queue. The fault-record that was attempted to 
                           be written is discarded and no more fault records 
                           are generated until software clears `fqmf` bit by 
                           writing 1 to the bit. An interrupt is generated if 
                           not already pending (i.e. `ipsr.fip == 1`) and not 
                           masked (i.e. `fqsr.fie == 0`).
|9     |`fqof`|RW1C      | The fault-queue-overflow bit is set to 1 if the 
                            IOMMU needs to queue a fault record but the 
                            fault-queue is full (i.e., `fqh == fqt - 1`). +
                                                                               +
                            The fault-record is discarded and no more fault 
                            records are generated till software clears `fqof` 
                            by writing 1 to the bit. An interrupt is generated 
                            if not already pending (i.e. `ipsr.fip == 1`) and 
                            not masked (i.e. `fqsr.fie == 0`).
|10:15 |`reserved`|WPRI  | Reserved for standard use
|16    |`fqon`|RO        | The fault-queue is active if `fqon` reads 1.
                           IOMMU behavior on changing `fqb` when `busy` is 1 
                           or `fqon` is 1 is `UNSPECIFIED`. The 
                           recommended sequence to change `fqb` is to first 
                           disable the fault-queue by clearing `fqen` and 
                           waiting for both `busy` and `fqon` to be 0 before 
                           changing `fqb`.
|17    |`busy`|RO        | Write to `fqcsr` may require the IOMMU to perform 
                           many operations that may not occur synchronously to 
                           the write.
                           When a write is observed by the fqcsr, the `busy` 
                           bit is set to 1. When the `busy` bit is 1, behavior 
                           of additional writes to the `fqcsr` are 
                           `UNSPECIFIED`. Some implementations may 
                           ignore the second write and others may perform the 
                           actions determined by the second write. +
                                                                               +
                           Software should ensure that the `busy` bit is 0 
                           before writing to the `fqcsr`. +
                                                                               +
                           An IOMMU that can complete controls synchronously 
                           may hard-wire this bit to 0. 
|27:18 |`reserved`|WPRI  | Reserved for standard use
|31:28 |_custom_  |WPRI  | _Designated for custom use._
|===

[[PQCSR]]
=== Page-request-queue CSR (`pqcsr`)

This 32-bits register (RW) is used to control the operations and report the
status of the page-request-queue.

.Page-request-queue CSR register fields

[wavedrom, , ]
....
{reg: [
  {bits: 1, name: 'pqen'},
  {bits: 1, name: 'pie'},
  {bits: 6, name: 'reserved'},
  {bits: 1, name: 'pqmf'},
  {bits: 1, name: 'pqof'},
  {bits: 6, name: 'reserved'},
  {bits: 1, name: 'pqon'},
  {bits: 1, name: 'busy'},
  {bits: 10, name: 'reserved'},
  {bits: 4, name: 'Custom use'},
], config:{lanes: 4, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits  |Field    |Attribute | Description
|0     |`pqen`   |RW        | The page-request-enable bit enables the
                              page-request-queue when set to 1. +
                                                                               +
                              Changing `pqen` from 0 to 1, resets the `pqh` 
                              and `pqt` to 0 and clears `pqcsr` bits `pqmf` and
                              `pqof` to 0. The page-request-queue may take 
                              some time to be active following setting the 
                              `pqen` to 1. When the page-request-queue is 
                              active, the `pqon` bit reads 1. +
                                                                               +
                              When `pqen` is changed from 1 to 0, the 
                              page-request-queue may stay active till in-flight 
                              page-request writes are completed. When the
                              page-request-queue turns off, the `pqon` bit 
                              reads 0, `pqh` is set to 0, `pqt` is set to 0 and 
                              the `pqcsr` bits `pqof`, and `pqmf` are set to 0. +
                                                                               +
                              When `pqon` reads 0, the IOMMU guarantees that 
                              there are no older in-flight implicit writes to 
                              the queue memory and no further implicit writes 
                              will be generated to the queue memory. +
                                                                               +
                              The IOMMU may respond to “Page Request” messages 
                              received when page-request-queue is off or in 
                              the process of being turned off, as specified in
                              <<ATS_PRI>>.
|1     |`pie`     |RW       | The page-request-queue-interrupt-enable (`pie`) 
                              bit when set to 1, enables generation of 
                              interrupts from page-request-queue.
|7:2   |`reserved`|WPRI     | Reserved for standard use
|8     |`pqmf`    |RW1C     | The `pqmf` bit is set to 1 if the IOMMU 
                              encounters an access fault when storing a 
                              page-request message to the page-request-queue. +
                                                                               +
                              When `pqmf` is set to 1, an interrupt is 
                              generated if not already pending 
                              (i.e. `ipsr.pip == 1`) and not masked 
                              (i.e. `pqsr.pie == 1`). +
                                                                               +
                              The "Page Request" message that caused the `pqmf` 
                              or `pqof` error and all subsequent page-request 
                              messages are discarded till software clears the 
                              `pqof` and/or `pqmf` bits by writing 1 to it. +
                                                                               +
                              The IOMMU may respond to “Page Request” messages 
                              that caused the `pqof` or `pqmf` bit to be set 
                              and all subsequent “Page Request” messages 
                              received while these bits are 1 as specified in
                              <<ATS_PRI>>.
|9     |`pqof`    |RW1C     | The page-request-queue-overflow bit is set to 1 
                              if the page-request queue overflows i.e. IOMMU 
                              needs to queue a page-request message but the 
                              page-request queue is full 
                              (i.e., `pqh == pqt - 1`). +
                                                                               +
                              When `pqof` is set to 1, an interrupt is 
                              generated if not already pending 
                              (i.e. `ipsr.pip == 1`) and not masked 
                              (i.e. `pqsr.pie == 1`). +
                                                                               +
                              The "Page Request" message that caused the `pqmf` 
                              or `pqof` error and all subsequent page-request 
                              messages are discarded till software clears the 
                              `pqof` and/or `pqmf` bits by writing 1 to it. +
                                                                               +
                              The IOMMU may respond to “Page Request” messages 
                              that caused the `pqof` or `pqmf` bit to be set 
                              and all subsequent “Page Request” messages 
                              received while these bits are 1 as specified in
                              <<ATS_PRI>>.
|15:10 |`reserved`|WPRI     | Reserved for standard use
|16    |`pqon`    |RO       | The page-request is active when `pqon` reads 1. +
                                                                               +
                              IOMMU behavior on changing `pqb` when `busy` is 1
                              or `pqon` is 1 is `UNSPECIFIED`. The 
                              recommended sequence to change `pqb` is to first 
                              disable the page-request queue by clearing `pqen`
                              and waiting for both `busy` and `pqon` to be 0 
                              before changing `pqb`.
|17    |`busy`    |RO       | A write to `pqcsr` may require the IOMMU to 
                              perform many operations that may not occur 
                              synchronously to the write. When a write is 
                              observed by the `pqcsr`, the `busy` bit is set 
                              to 1. +
                                                                               +
                              When the `busy` bit is 1, behavior of additional 
                              writes to the `pqcsr` are `UNSPECIFIED`.
                              Some implementations may ignore the second write 
                              and others may perform the actions determined by 
                              the second write. Software should ensure that the
                              `busy` bit is 0 before writing to the `pqcsr`. +
                                                                               +
                              An IOMMU that can complete controls synchronously
                              may hard-wire this bit to 0
|27:18 |`reserved`|WPRI     | Reserved for standard use
|31:28 |_custom_  |WPRI     | _Designated for custom use._
|===

[[IPSR]]
=== Interrupt pending status register (`ipsr`)
This 32-bits register (RW1C) reports the pending interrupts which require 
software service. Each interrupt-pending bit in the register corresponds to 
a interrupt source in the IOMMU. When an interrupt-pending bit in the register
is set to 1 the IOMMU will not signal another interrupt from that source till
software clears that interrupt-pending bit by writing 1 to clear it.

.Interrupt pending status register fields

[wavedrom, , ]
....
{reg: [
  {bits: 1, name: 'cip'},
  {bits: 1, name: 'fip'},
  {bits: 1, name: 'pmip'},
  {bits: 1, name: 'pip'},
  {bits: 4, name: 'reserved'},
  {bits: 8, name: 'custom'},
  {bits: 16, name: 'reserved'},
], config:{lanes: 2, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits   |Field   |Attribute | Description
|0      |`cip`   |RW1C      | The command-queue-interrupt-pending
|1      |`fip`   |RW1C      | The fault-queue-interrupt-pending
|2      | `pmip` |RW1C      | The performance-monitoring-interrupt-pending
|3      | `pip`  |RW1C      | The page-request-queue-interrupt-pending
|7:4    |`reserved`  |WPRI  | Reserved for standard use
|15:8   |_custom_    |WPRI  | _Designated for custom use._
|31:16  |`reserved`  |WPRI  | Reserved for standard use
|===

[[OVF]]
=== Performance-monitoring counter overflow status (`iocountovf`)
The performance-monitoring counter overflow status is a 32-bit read-only
register that contains shadow copies of the OF bits in the `iohpmevt1-31`
registers - where `iocntovf` bit X corresponds to `iohpmevtX` and bit 0
corresponds to the `OF` bit of `iohpmcycles`.

This register enables overflow interrupt handler software to quickly and easily
determine which counter(s) have overflowed.

.Performance-monitoring counter overflow status register fields

[wavedrom, , ]
....
{reg: [
  {bits:  1, name: 'CY'},
  {bits: 31, name: 'HPM'},
], config:{lanes: 1, hspace:1024}}
....


[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits   |Field   |Attribute | Description
|0      |`CY`    |RO        | Shadow of `iohpmcycles.OF`
|31:1   |`HPM`   |RO        | Shadow of `iohpmevt[1-31].OF`
|===

[[INH]]
=== Performance-monitoring counter inhibits (`iocountinh`)
The performance-monitoring counter inhibits is a 32-bits WARL register where
that contains bits to inhibit the corresponding counters from counting. Bit X
when set inhibits counting in `iohpmctrX` and bit 0 inhibits counting in
`iohpmcycles`.

.Performance-monitoring counter inhibits register fields

[wavedrom, , ]
....
{reg: [
  {bits:  1, name: 'CY'},
  {bits: 31, name: 'HPM'},
], config:{lanes: 1, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits   |Field   |Attribute | Description
|0      |`CY`    |RW        | When set, `iohpmcycles` counter is inhibited 
                              from counting.
|31:1   |`HPM`   |WARL      | When bit X is set, then counting of events in
                              `iohpmctrX` is inhibited.
|===

[NOTE]
====
When the `iohpmcycles` counter is not needed, it is desirable to conditionally
inhibit it to reduce energy consumption. Providing a single register to 
inhibit all counters allows a) one or more counters to be atomically programmed
with events to count b) one or more counters to be sampled atomically.
====

[[CYC]]
=== Performance-monitoring cycles counter (`iohpmcycles`)
This 64-bits register is a free running clock cycle counter.
There is no associated `iohpmevt0`.

.Performance-monitoring cycles counter register fields

[wavedrom, , ]
....
{reg: [
  {bits: 63, name: 'counter'},
  {bits: 1, name: 'OF'},
], config:{lanes: 2, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits   |Field    |Attribute | Description
|62:0   |`counter`|WARL      | Cycles counter value.
|63     |`OF`     |RW        | Overflow
|===

When `capabilities.HPM` is set, the `iohpmcycles` register must be present and
be at least a 32-bits wide.

[[CTR]]
=== Performance-monitoring event counters (`iohpmctr1-31`)
These registers are 64-bit WARL counter registers.

.Performance-monitoring event counters register fields

[wavedrom, , ]
....
{reg: [
  {bits: 64, name: 'counter'},
], config:{lanes: 1, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits   |Field    |Attribute | Description
|63:0   |`counter`|WARL      | Event counter value.
|===

When `capabilities.HPM` is set, the `iohpmcycles` and the `iohpmctr1` register
must be present and be at least 32-bits wide.

[[EVT]]
=== Performance-monitoring event selector (`iohpmevt1-31`)
These performance-monitoring event registers are 64-bit RW registers. When a
transaction processed by the IOMMU causes an event that is programmed to count
in a counter then the counter is incremented. In addition to matching events
the event selector may be programmed with additional filters based on
`device_id`, `process_id`, `GSCID`, and `PSCID` such that the counter is 
incremented conditionally based on the transaction matching these additional
filters. When such `device_id` based filtering is used, the match may be 
configured to be a precise match or a partial match. A partial match allows
a transactions with a range of IDs to be counted by the counter.

.Performance-monitoring event selector register fields

[wavedrom, , ]
....
{reg: [
  {bits: 15, name: 'eventID'},
  {bits: 1, name: 'DMASK'},
  {bits: 20, name: 'PID_PSCID'},
  {bits: 24, name: 'DID_GSCID'},
  {bits: 1, name: 'PV_PSCV'},
  {bits: 1, name: 'DV_GSCV'},
  {bits: 1, name: 'IDT'},
  {bits: 1, name: 'OF'},
], config:{lanes: 8, hspace:1024}}
....

[width=100%]
[%header, cols="^1,2,^1,5"]
|===
|Bits   |Field      |Attribute | Description
|14:0   |`eventID`  |WARL     a| Indicates the event to count. A value of 0 
                                 indicates no events are counted. +
                                 Encoding 1 to 16383 are reserved for standard
                                 events defined in the <<Event_list>>. +
                                 Encoding 16384 to 32767 are for designated for 
                                 custom use. +
                                 When `eventID` is changed, including to 0, 
                                 the counter retains its value.
|15     |`DMASK`    |RW        | When set to 1, partial matching of the
                                 `DID_GSCID` is performed for the transaction.
                                 The lower bits of the `DID_GSCID` all the way 
                                 to the first low order 0 bit (including
                                 the 0 bit position itself) are masked.
|35:16  |`PID_PSCID`|RW        | `process_id` if `IDT` is 0, 
                                 `PSCID` if `IDT` is 1
| 59:36 |`DID_GSCID`|RW        | `device_id` if `IDT` is 0, 
                                 `GSCID` if `IDT` is 1.
| 60    |`PV_PSCV`  |RW        | If set, only transactions with matching
                                 `process_id` or `PSCID` (based on the Filter 
                                 ID Type) are counted.
| 61    |`DV_GSCV`  |RW        | If set, only transactions with matching
                                 `device_id` or `GSCID` (based on the Filter ID
                                 Type) are counted.
| 62    |`IDT`      |RW        | Filter ID Type: This field indicates the type 
                                 of ID to filter on. When 0, the `DID_GSCID`
                                 field holds a `device_id` and the `PID_PSCID` 
                                 field holds a `process_id`. When 1, the
                                 `DID_GSCID` field holds a `GSCID` and
                                 `PID_PSCID` field holds a `PSCID`.
| 63    |`OF`       |RW        | Overflow status or Interrupt disable 
|===

When `capabilities.HPM` is set, the `iohpmcycles` and the `iohpmevt1` register
must be present and be at least 32-bits wide.

The table below summarizes the filtering option for events that support 
filtering by IDs.

.filtering options
[cols="^1,1,1,5", options="header"]
|===
| *`IDT`* | *`DV_GSCV`* | *`PV_PSCV`* | *Operation*
| 0/1     | 0           | 0           | Counter increments. No ID based
                                        filtering.
| 0       |  0          | 1           | If the transaction has a valid
                                        `process_id`, counter increments if
                                        process_id matches `PID_PSCID`.
| 0       |  1          | 0           | Counter incremented if `device_id`
                                        matches `DID_GSCID`.
| 0       |  1          | 1           | If the transaction does not have a
                                        valid `process_id`, counter increments
                                        if `device_id` matches `DID_GSCID`.
                                        If the transaction has a valid
                                        `process_id`, counter increments if
                                        `device_id` matches `DID_GSCID` and
                                        `process_id` matches `PID_PSCID`.
| 1       |  0          | 1           | If the transaction has a valid
                                        `process_id`, counter increments if 
                                        the `PSCID` of that process matches
                                        `PID_PSCID`.
| 1       |  1          | 0           | Counter incremented if `GSCID` of the
                                        device matches `DID_GSCID`.
| 1       |  1          | 1           | If the transaction does not have a
                                        valid `process_id`, counter increments
                                        if `GSCID` of the device matches
                                        `DID_GSCID`.
                                        If the transaction has a valid
                                        `process_id`, counter increments if
                                        `GSCID` of the device matches
                                        `DID_GSCID` and `PSCID` of the process
                                         matches `PID_PSCID`.
|===

When filtering by `device_id` or `GSCID` is selected and the event supports
ID based filtering, the DMASK field can be used to configure a partial match.
When DMASK is set to 1, partial matching of the `DID_GSCID` is performed for
the transaction. The lower bits of the `DID_GSCID` all the way to the first 
low order 0 bit (including the 0 bit position itself) are masked.

The following example illustrates the use of DMASK and filtering by `device_id`.

.`DMASK` with `IDT` set to `device_id` based filtering
[cols="^1,3,3", options="header"]
|===
| `DMASK` | `DID_GSCID`                  | *Comment*
| 0       |`yyyyyyyy  yyyyyyyy  yyyyyyyy`| One specific seg:bus:dev:func
| 1       |`yyyyyyyy  yyyyyyyy  yyyyy011`| seg:bus:dev - any func
| 1       |`yyyyyyyy  yyyyyyyy  01111111`| seg:bus - any dev:func
| 1       |`yyyyyyyy  01111111  11111111`| seg - any bus:dev:func
|===

The following table lists the standard events that can be counted:

[[Event_list]]
.Standard Events list
[cols="^1,3,^3", options="header"]
|===
| *eventID*  | *Event counted*              | *IDT settings supported*
| 0          | Do not count                 | 
| 1          | Untranslated requests        | 0
| 2          | Translated requests          | 0
| 3          | ATS Translation requests     | 0
| 4          | TLB miss                     | 0/1
| 5          | Device Directory Walks       | 0 
| 6          | Process Directory Walks      | 0
| 7          | S/VS-stage Page Table Walks  | 0/1
| 8          | G-stage Page Table Walks     | 0/1
| 9 - 16383 | reserved for future standard | -
|===

Some events types may be filtered by IDs. When a event type that does not 
support filtering by IDs is programmed then the associated counter does not
increment.

The `OF` bit is set when the corresponding `iohpmctr1-31` counter overflows, 
and remains set until cleared by software. Since `iohpmctr1-31` values are 
unsigned values, overflow is defined as unsigned overflow. Note that there is no
loss of information after an overflow since the counter wraps around and keeps 
counting while the sticky `OF` bit remains set.

If a `iohpmctr1-31` counter overflows when the associated `OF` bit is zero, then
a HPM Counter Overflow interrupt is generated by setting `ipsr.pmip` bit to 1. If
the `OF` bit is already one, then no interrupt request is generated. Consequently
the `OF` bit also functions as a count overflow interrupt disable for the 
associated `iohpmctr1-31`.

[NOTE]
====
There are not separate overflow status and overflow interrupt enable bits. In
practice, enabling overflow interrupt generation (by clearing the `OF` bit) is
done in conjunction with initializing the counter to a starting value. Once a
counter has overflowed, it and the `OF` bit must be reinitialized before
another overflow interrupt can be generated.
====

[NOTE]
====
In RV32, memory-mapped writes to `iohpmevt1-31` modify only one 32-bit part of 
the register. The following sequence may be used to update the register without
counting events spuriously due to the intermediate value of the register:

* Write the low order 32-bits to set `eventID` to 0.
* Write the high order 32-bits with the new desired values.
* Write the low order 32-bits the new desired values, including that of the
  `eventID` field.

Alternatively, the counter may first be inhibited such that no events count
during the update and the inhibit removed after the register has been programmed
with the desired value.
====

[NOTE]
====
A minimum of one programmable event counter besides the cycles counter is 
required to comply with this specification. One counter may be used in a time
multiplexed manner to sample events but such analysis may take longer to
complete. The IOMMU, unlike the CPU MMU, services multiple streams of IO and
the HPM may be used by a performance analyst to analyze one or more of those
streams concurrently. Typically a performance analyst may require four 
programmable counters, to count events for an IO stream. To support concurrent
analysis of at least two streams of IO it is recommended to support seven 
programmable counters.
====


[[ICVEC]]
=== Interrupt-cause-to-vector register (`icvec`)

Interrupt-cause-to-vector register maps a cause to a vector.  All causes can 
be mapped to same vector or a cause can be given a unique vector. 

The vector is used:

. By an IOMMU that generates interrupts as MSI, to index into MSI 
  configuration table (`msi_cfg_tbl`) to determine the MSI to generate. An 
  IOMMU is capable of generating interrupts as a MSI if `capabilities.IGS==MSI`
  or if `capabilities.IGS==BOTH`. When `capabilities.IGS==BOTH` the IOMMU may be
  configured to generate interrupts as MSI by setting `fctl.WSI` to 0.
. By an IOMMU that generates WSI, to determine the wire 
  to signal the interrupt. An IOMMU is capable of generating wire-signaled-
  interrupts if `capabilities.IGS==WSI` or if `capabilities.IGS==BOTH`. When 
  `capabilities.IGS==BOTH` the IOMMU may be configured to generate wire-signaled-
  interrupts by setting `fctl.WSI` to 1.

If an implementation only supports a single vector then all bits of this
register may be hardwired to 0 (WARL). Likewise if only two vectors are 
supported then only bit 0 for each cause could be writable.

.Interrupt-cause-to-vector register fields

[wavedrom, , ]
....
{reg: [
  {bits: 4, name: 'civ'},
  {bits: 4, name: 'fiv'},
  {bits: 4, name: 'pmiv'},
  {bits: 4, name: 'piv'},
  {bits: 16, name: 'reserved'},
  {bits: 32, name: 'custom'},
], config:{lanes: 4, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits   |Field    |Attribute | Description
| 3:0   |`civ`    |WARL      | The command-queue-interrupt-vector (`civ`) 
                               is the vector number assigned to the 
                               command-queue-interrupt. 
| 7:4   |`fiv`    |WARL      | The fault-queue-interrupt-vector (`fiv`) is the
                               vector number assigned to the 
                               fault-queue-interrupt.
| 11:8  |`pmiv`   |WARL      | The performance-monitoring-interrupt-vector
                               (`pmiv`) is the vector number assigned to the
                               performance-monitoring-interrupt. 
| 15:12 |`piv`    |WARL      | The page-request-queue-interrupt-vector (`piv`)
                               is the vector number assigned to the
                               page-request-queue-interrupt.
| 31:16 |`reserved`|WPRI     | Reserved for standard use
| 63:32 |_custom_  |WPRI     | _Designated for custom use_
|===

[[TRR_IOVA]]
=== Translation-request IOVA (`tr_req_iova`)
The `tr_req_iova` is a 64-bit WARL register used to implement a 
translation-request interface for debug. This register is present when 
`capabilities.DBG == 1`.

.Translation-request IOVA register fields

[wavedrom, , ]
....
{reg: [
  {bits: 12, name: 'pgoff'},
  {bits: 52, name: 'iova_vpn'},
], config:{lanes: 2, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits   |Field      |Attribute | Description
| 11:0  |`pgoff`    |WARL      | The IOVA page-offset
| 63:12 |`iova_vpn` |WARL      | The IOVA virtual page number
|===


[[TRR_CTRL]]
=== Translation-request control (`tr_req_ctl`)
The `tr_req_ctl` is a 64-bit WARL register used to implement a 
translation-request interface for debug. This register is present when
`capabilities.DBG == 1`.

.Translation-request control register fields
[wavedrom, , ]
....
{reg: [
  {bits: 1, name: 'Go/Busy'},
  {bits: 1, name: 'Priv'},
  {bits: 1, name: 'Exe'},
  {bits: 1, name: 'RWn'},
  {bits: 8, name: 'reserved'},
  {bits: 20, name: 'PID'},
  {bits: 1, name: 'PV'},
  {bits: 3, name: 'reserved'},
  {bits: 4, name: 'custom'},
  {bits: 24, name: 'DID'},
], config:{lanes: 4, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits   |Field      |Attribute | Description
| 0     |`Go/Busy`  |RW1S      | This bit is set to indicate a valid 
                                 request has been setup in the 
                                 `tr_req_iova/tr_req_ctl` registers
                                 for the IOMMU to translate. +
                                                                               +
                                 The IOMMU indicates completion of the
                                 requested translation by clearing this
                                 bit to 0. On completion, the results 
                                 of the translation are in `tr_response`
                                 register.
| 1     |`Priv`     |WARL      | When set to 1 the requests needs Privileged
                                 Mode access for this translation.
| 2     |`Exe`      |WARL      | When set to 1 the request needs execute
                                 access for this translation.
| 3     |`RWn`      |WARL      | When set to 1 the request only needs
                                 read-only access for this translation.
| 11:4  |reserved   |WPRI      | Reserved for standard use
| 31:12 |`PID`      |WARL      | When `PV` is 1 this field provides the
                                 `process_id` for this translation 
                                 request.
| 32    |`PV`       |WARL      | When set to 1 the `PID` field of the 
                                 register is valid.
| 35:33 |reserved   |WPRI      | Reserved for standard use
| 39:36 a|_custom_  |WPRI     a| _Designated for custom use_
| 63:40 |`DID`      |WARL      | This field provides the `device_id` for
                                 this translation request.
|===


[[TRR_RSP]]
=== Translation-response (`tr_response`)
The `tr_response` is a 64-bit RO register used to hold the results
of a translation requested using the translation-request interface.
This register is present when `capabilities.DBG == 1`.

.Translation-response register fields
[wavedrom, , ]
....
{reg: [
  {bits: 1, name: 'fault'},
  {bits: 6, name: 'reserved'},
  {bits: 2, name: 'PBMT'},
  {bits: 1, name: 'S'},
  {bits: 44, name: 'PPN'},
  {bits: 6, name: 'reserved'},
  {bits: 4, name: 'custom'},
], config:{lanes: 4, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits   |Field      |Attribute | Description
|0      |`fault`    |RO        | If the process to translate the IOVA detects
                                 a fault then the `fault` field is set to 1.
                                 The detected fault may be reported through the
                                 fault-queue.
|6:1    |reserved   |RO        | Reserved for standard use
|8:7    |`PBMT`     |RO        | Memory type determined for the translation 
                                 using the PBMT fields in the S/VS-stage and/or
                                 the G-stage page tables used for the 
                                 translation. This value of field is 
                                 `UNSPECIFIED` if the `fault` field is 1.
|9      |`S`        |RO        | Translation range size field, when set to 1
                                 indicates that the translation applies to a
                                 range that is larger than 4 KiB and the size
                                 of the translation range is encoded in the 
                                 `PPN` field. The value of this field is 
                                 `UNSPECIFIED` if the `fault` field is 1.
|53:10  |`PPN`      |RO       a| If the `fault` bit is 0, then this field
                                 provides the PPN determined as a result of
                                 translating the `iova_vpn` in `tr_req_iova`. +
 +
                                 If the `fault` bit is 1, then the value of
                                 this field is `UNSPECIFIED`. +
 +
                                 If the `S` bit is 0, then the size of the
                                 translation is 4 KiB - a page. +
 +
                                 If the `S` bit is 1, then the translation
                                 resulted in a super-page, and the size of the
                                 super-page is encoded in the PPN itself. If
                                 scanning from bit position 0 to bit position 
                                 43, the first bit with a value of 0 at 
                                 position `X`, then the super-page size is 
                                `2^X+1^ * 4` KiB. +
 +
                                 If `X` is not 0, then all bits at position 0
                                 through `X-1` are each encoded with a value 
                                 of 1.
 +

.Example of encoding of super page size in `PPN`
[width=80%]
[%header, cols="3,^1,2"]
!===
                                !           `PPN`          !`S`!   Size
                                !`yyyy....yyyy yyyy yyyy`  !`0`!  4 KiB
                                !`yyyy....yyyy yyyy 0111`  !`1`! 64 KiB
                                !`yyyy....yyy0 1111 1111`  !`1`!  2 MiB
                                !`yyyy....yy01 1111 1111`  !`1`!  4 MiB
!===
|59:54 |reserved |RO          | Reserved for standard use
|63:60 a|_custom_|RO         a| _Designated for custom use_
|===

[[MSI]]
=== MSI configuration table (`msi_cfg_tbl`)
IOMMU that supports generating IOMMU originated interrupts 
(i.e., `capabilities.IGS == MSI` or `capabilities.IGS == BOTH`) as MSI 
implements a MSI configuration table that is indexed by the vector from `icvec`
to determine a MSI table entry. Each MSI table entry for interrupt vector `x` 
has three registers `msi_addr_x`, `msi_data_x`, and `msi_vec_ctl_x`. These 
registers are hardwired to 0 if `capabilities.IGS == WSI`.

If an access fault is detected on a MSI write using `msi_addr_x`, then the IOMMU
reports a "IOMMU MSI write access fault" (cause 273) fault, with `TTYP` set to 0
and `iotval` set to the value of `msi_addr_x`.

.MSI configuration table structure
[width=100%]
[%header, cols="10,10,3"]
|===
|bit 63                 >s|                   bit 0|Byte Offset
2+^|Entry 0: Message address                       |+000h      
^|Entry 0: Vector Control  ^|Entry 0: Message Data |+008h      
2+^|Entry 1: Message address                       |+010h      
^|Entry 1: Vector Control  ^|Entry 1: Message Data |+018h      
2+^|...                                            |+020h     
|===

.Message address register fields
[wavedrom, , ]
....
{reg: [
  {bits: 2, name: '0'},
  {bits: 54, name: 'ADDR'},
  {bits: 8, name: 'WPRI'},
], config:{lanes: 2, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits   |Field |Attribute |Description
|1:0    | 0    |RO     |Fixed to 0
|55:2   |`ADDR`|WARL   |Holds the 4-byte aligned MSI address.
|63:56  |`WPRI`|WPRI   | Reserved for standard use.
|===


.Message data register fields
[wavedrom, , ]
....
{reg: [
  {bits: 32, name: 'data'},
], config:{lanes: 1, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits   |Field |Attribute |Description
|31:0   |`data`| RW       | Holds the 4-byte MSI data
|===


.Vector control register fields
[wavedrom, , ]
....
{reg: [
  {bits: 1, name: 'M'},
  {bits: 31, name: 'WPRI'},
], config:{lanes: 1, hspace:1024}}
....
[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits   |Field |Attribute | Description
|0      |`M`   |RW        | When the mask bit `M` is 1, the corresponding 
                            interrupt vector is masked and the IOMMU is 
                            prohibited from sending the associated message.
                            Pending message for that vector are later
                            generated if the corresponding mask bit is
                            cleared to 0.
|31:1   |`WPRI`|WPRI      | Reserved for standard use.
|===
